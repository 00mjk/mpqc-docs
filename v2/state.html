<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPQC: The State Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPQC
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The State Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The state library provides means for objects to save and restore their state. Features include:</p>
<ul>
<li>
Pointers to base types can be saved and restored. The exact types of the saved and restored objects will match. </li>
<li>
If the pointer to an object is saved twice, only one copy of the object is saved. When these two pointers are restored they will point to the same object. </li>
<li>
Virtual base classes are dealt with in a manner consistent with the way C++ treats virtual base classes. </li>
<li>
The library is portable. Information about object layout for particular compiler implementations is not needed. </li>
</ul>
<p>For objects of a class to be savable with this library the class must inherit SavableState which in turn inherits DescribedClass. SavableState must be inherited with the virtual qualifier. Also, a constructor taking a StateIn&amp; argument and a save_data_state(StateOut&amp;) member must be provided. If the class has virtual base classes other than SavableState, then a save_vbase_state(StateOut&amp;) member must also be provided.</p>
<ul>
<li>
<a class="el" href="state.html#stateex">Simple Example</a> </li>
<li>
<a class="el" href="state.html#stateexin">Example with Inheritance</a> </li>
<li>
<a class="el" href="state.html#stateexvin">Example with Virtual and Nonvirtual Inheritance</a> </li>
<li>
<a class="el" href="state.html#stateexpoint">Example with Pointers to SavableStates</a> </li>
<li>
<a class="el" href="state.html#stateexsmart">Example with Smart Pointers to SavableStates</a> </li>
<li>
<a class="el" href="state.html#stateexdata">Example with Pointers to Data</a> </li>
</ul>
<h1><a class="anchor" id="stateex"></a>
Simple Example</h1>
<p>Here is a simple example of the specification of a client, C, of SavableState: </p><pre>
class C: virtual public SavableState {
  private:
    int i;
  public:
    C(StateIn&amp;);
    void save_data_state(StateOut&amp;);
};
</pre><p>Here is the implementation for the above: </p><pre>
static ClassDesc C_cd(typeid(C),"C",1,"virtual public SavableState",
                      0, 0, create&lt;C&gt;);
void C::save_data_state(StateOut&amp;so) {
  so.put(i);
}
C::C(StateIn&amp;si): SavableState(si) {
  si.get(i);
}
</pre><h1><a class="anchor" id="stateexin"></a>
Example with Inheritance</h1>
<p>Here is an example of the specification of C, where C nonvirtually inherits from another SavableState derivative: </p><pre>
class C: public B {
  private:
    int i;
  public:
    C(StateIn&amp;);
    void save_data_state(StateOut&amp;);
};
</pre><p>Here is the implementation for the above: </p><pre>
static ClassDesc C_cd(typeid(C),"C",1,"public B",
                      0, 0, create&lt;C&gt;);
void C::save_data_state(StateOut&amp;so) {
  B::save_data_state(so);
  so.put(i);
}
C::C(StateIn&amp;si): SavableState(si), B(si)  {
  si.get(i);
}
</pre><p>Note that B (or one of its parents) virtually inherits from SavableState, so the StateIn constructor for SavableState is called explicitly from the class C constructor.</p>
<h1><a class="anchor" id="stateexvin"></a>
Example with Virtual and Nonvirtual Inheritance</h1>
<p>Here is an example of the specification of C, where C nonvirtually inherits from another client of SavableState as well as virtually inherits from a client of SavableState: </p><pre>
class C: public B,
         virtual public E {
  private:
    int i;
  public:
    C(StateIn&amp;);
    void save_vbase_state(StateOut&amp;);
    void save_data_state(StateOut&amp;);
  };
</pre><p>In this case a save_vbase_state member is required since virtual base classes besides SavableState exist. This member function must save the virtual base classes in the same order that virtual base classes are initialized in constructors. Virtual base classes are initialized before all other base classes in a depth first, left to right transversal of the directed acyclic graph of parent classes. In this example, B and E inherit virtually from SavableState. Here is the implementation: </p><pre>
static ClassDesc C_cd(typeid(C),"C",1,"public B, virtual public E",
                      0, 0, create&lt;C&gt;);
void C::save_vbase_state(StateOut&amp;sio) {
  SavableState::save_data_state(so);
  E::save_data_state(sio);
}
void C::save_data_state(StateOut&amp;so) {
  B::save_parent_state(so);
  so.put(i);
}
C::C(StateIn&amp;si): SavableState(si), B(si), E(si) {
  si.get(i);
}
</pre><h1><a class="anchor" id="stateexpoint"></a>
Example with Pointers to SavableStates</h1>
<p>Here is an example where C has data members which are pointers to derivatives of SavableState: </p><pre>
class C: virtual public SavableState {
  private:
    A* ap; // A is also a SavableState
  public:
    C(StateIn&amp;);
    void save_data_state(StateOut&amp;);
  };
</pre><p>Here is the implementation for the above: </p><pre>
static ClassDesc C_cd(typeid(C),"C",1,"virtual public SavableState",
                      0, 0, create&lt;C&gt;);
void C::save_data_state(StateOut&amp;so) {
  SavableState::save_state(ap,so);
}
C::C(StateIn&amp;si): SavableState(si) {
  ap = dynamic_cast&lt;A&gt;(SavableState::restore_state(si));
}
</pre><h1><a class="anchor" id="stateexsmart"></a>
Example with Smart Pointers to SavableStates</h1>
<p>Here is an example where C has data members which are smart pointers to derivatives of SavableState: </p><pre>
class C: virtual public SavableState {
  private:
    Ref a; // A is also a SavableState
  public:
    C(StateIn&amp;);
    void save_data_state(StateOut&amp;);
};
</pre><p>Here is the implementation for the above: </p><pre>
static ClassDesc C_cd(typeid(C),"C",1,"virtual public SavableState",
                      0, 0, create&lt;C&gt;);
void C::save_data_state(StateOut&amp;so) {
  SavableState::save_state(a.pointer(),so);
}
C::C(StateIn&amp;si): SavableState(si) {
  a &lt;&lt; SavableState::restore_state(so);
}
</pre><h1><a class="anchor" id="stateexdata"></a>
Example with Pointers to Data</h1>
<p>Here is an example where C has data members which are pointers to data: </p><pre>
class C: virtual public SavableState {
  private:
    int vecsize;
    double *vec;
    int n1;
    int n2;
    double **array;
  public:
    C(StateIn&amp;);
    void save_data_state(StateOut&amp;);
};
</pre><p>Here is the implementation for the above: </p><pre>
static ClassDesc C_cd(typeid(C),"C",1,"virtual public SavableState",
                      0, 0, create&lt;C&gt;);
void C::save_data_state(StateOut&amp;so) {
  so.put(vecsize);
  so.put_array_double(vec,vecsize);</pre><pre>  so.put(n1);
  so.put(n2);
  for (int i=0; i&lt;n1; i++) {
    so.put_array_double(array[i],n2);
  }
}
C::C(StateIn&amp;si): SavableState(si) {
  si.get(vecsize);
  vec = new double[vecsize];
  si.get_array_double(vec,vecsize);</pre><pre>  si.get(n1);
  si.get(n2);</pre><pre>  array = new double*[n1];
  for (int i=0; i&lt;n1; i++) {
    array[i] = new double[n2];
    si.get_array_double(array[i],n2);
  }
}
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<hr>
<address>
<small>
Generated at Sun Jan 26 2020 23:33:05 for <a
href="http://www.mpqc.org">MPQC</a>
2.3.1 using the documentation package <a
href="http://www.doxygen.org">Doxygen</a>
1.8.16.
</small>
</address>
</body>
</html>
