<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPQC: Object-Oriented Input</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPQC
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Object-Oriented Input </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>MPQC is an object-oriented program that directly allows the user to specify objects that MPQC then manipulates to obtain energies, properties, etc. This makes the input very flexible, but very complex. However, most calculations should be quite similar to the one of the examples given later in this chapter. The best way to get started is to use one of the example input files and modify it to meet your needs.</p>
<p>The object-oriented input format is described in the following sections:</p>
<ul>
<li>
<a class="el" href="mpqcoo.html#mpqcooover">Overview of the Object-Oriented Input</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoowalk">A Walk-Through of an Object-Oriented Input File</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamp">Sample Object-Oriented Input Files</a> </li>
</ul>
<h1><a class="anchor" id="mpqcooover"></a>
Overview of the Object-Oriented Input</h1>
<p>MPQC starts off by creating a ParsedKeyVal object that parses the input file specified on the command line. The format of the input file is documented in the KeyVal documentation(see <a class="el" href="keyval.html">The KeyVal Library</a>). It is basically a free format input that associates keywords and logical groupings of keywords with values. The values can be scalars, arrays, or objects.</p>
<p>The keywords recognized by MPQC begin with the mpqc prefix. That is, they must be nested between an <code>mpqc:(</code> and a <code>)</code>. Alternately, each keyword can be individually prefixed by <code>mpqc:</code>. The primary keywords are given below. Some of the keywords specify objects, in which case the object will require more ParsedKeyVal input. These objects are created from the input by using their ParsedKeyVal constructors. These constructors are documented with the source code documentation for the class.</p>
<dl>
<dt><code>mole</code></dt>
<dd><p class="startdd">This is the most important keyword for MPQC. It specifies the MolecularEnergy object. This is an object that knows how to compute the energy of a molecule. The specializations of MolecularEnergy that are most commonly used are CLKS, HSOSKS, UKS, CLHF, HSOSHF, UHF, and MBPT2.</p>
<p class="enddd"></p>
</dd>
<dt><code>opt</code></dt>
<dd><p class="startdd">This keyword must be specified for optimizations. It specifies an Optimize object. Usually, QNewtonOpt is best for finding minima and EFCOpt is best for transition states.</p>
<p class="enddd"></p>
</dd>
<dt><code>freq</code></dt>
<dd><p class="startdd">This keyword must be specified to compute frequencies. It specifies a MolecularFrequencies object.</p>
<p class="enddd"></p>
</dd>
<dt><code>thread</code></dt>
<dd><p class="startdd">This specifies an object of type ThreadGrp that can be used to advantage on shared-memory multiprocessor machines for certain types of calculations. This keyword can be overridden by giving the ThreadGrp in the environment or command line. See the section on running MPQC for more information.</p>
<p class="enddd"></p>
</dd>
<dt><code>integrals</code></dt>
<dd><p class="startdd">This specifies an object of type Integral that will be used as the default integral evaluator. If MP2-R12 is used, then this should be set to use IntegralCints with a line like <code>integrals&lt;IntegralCints&gt;: ()</code>.</p>
<p class="enddd"></p>
</dd>
<dt><code>checkpoint</code>  </dt>
<dd><p class="startdd">The value of this keyword is boolean. </p><pre class="fragment">    &lt;ul&gt;

    &lt;li&gt;&lt;tt&gt;true&lt;/tt&gt; and optimization is to be performed &lt;br&gt;

    &lt;tt&gt;opt&lt;/tt&gt; object will be checkpointed after each iteration.
    The checkpoint file suffix is ".ckpt".

    &lt;li&gt;&lt;tt&gt;true&lt;/tt&gt; and optimization is not performed &lt;br&gt;

    &lt;tt&gt;mole&lt;/tt&gt; object will be checkpointed at intermediate points.
    The manner in which
    &lt;tt&gt;mole&lt;/tt&gt; will be checkpointed depends on its particular type.
    The checkpoint file suffix is usually ".wfn", however
    in general it will depend on the particular specialization of
    &lt;tt&gt;MolecularEnergy&lt;/tt&gt;.

    &lt;/ul&gt;

    The default is to not checkpoint.
    &lt;/dd&gt;
</pre><p class="enddd"></p>
</dd>
<dt><code>checkpoint_freq</code></dt>
<dd><p class="startdd">This specifies how often to checkpoint certain MolecularEnergy specializations which compute iteratively. Currently, mole objects of SCF type can use this keyword. The default is 1, which means to checkpoint after every iteration.</p>
<p class="enddd"></p>
</dd>
<dt><code>savestate</code></dt>
<dd><p class="startdd">The value of this keyword is boolean. If true, then the states of the Optimize and MolecularEnergy objects will be saved after the calculation completes. The output file suffixes are ".ckpt" and ".wfn", respectively. The default is to save state.</p>
<p class="enddd"></p>
</dd>
<dt><code>restart</code></dt>
<dd><p class="startdd">The value of this keyword is boolean. If true, mpqc will attempt to restart the calculation. If the checkpoint file is not found, the calculation will continue as if the value were false. The default is true.</p>
<p class="enddd"></p>
</dd>
<dt><code>restart_file</code></dt>
<dd><p class="startdd">This gives the name of a file from which restart information is read. If the file name ends with ".wfn" then MPQC will try to restore a <code>MolecularEnergy</code> object from it and query for the <code>opt</code> object in the input file. If the file name ends with ".ckpt" MPQC will try to restore an <code>Optimize</code> object from this file. The default file name is formed by appending ".ckpt" to the input file name with the extension removed.</p>
<p class="enddd"></p>
</dd>
<dt><code>do_energy</code></dt>
<dd><p class="startdd">The value of this keyword is boolean. If true a single point energy calculation will be done for the MolecularEnergy object given with the mole keyword. The default is true.</p>
<p class="enddd"></p>
</dd>
<dt><code>do_gradient</code></dt>
<dd><p class="startdd">The value of this keyword is boolean. If true a single point gradient calculation will be done for the MolecularEnergy object given with the mole keyword. The default is false.</p>
<p class="enddd"></p>
</dd>
<dt><code>do_cca</code></dt>
<dd><p class="startdd">The value of this keywork is boolean. If true the cca embedded framework will be initialized. The default is false.</p>
<p class="enddd"></p>
</dd>
<dt><code>cca_path</code></dt>
<dd><p class="startdd">The value of this keyword is a string that provides a colon-separated list of directories in which CCA component libraries may be found.</p>
<p class="enddd"></p>
</dd>
<dt><code>cca_load</code></dt>
<dd><p class="startdd">The value of this keyword is a string that provides a colon-separated list of sidl class names for CCA components which will be instantiated from the libraries found in the path given by <code>cca_path</code>.</p>
<p class="enddd"></p>
</dd>
<dt><code>optimize</code></dt>
<dd><p class="startdd">The value of this keyword is boolean. If true and the opt keyword was set to a valid value, then an optimization will be performed. The default is true.</p>
<p class="enddd"></p>
</dd>
<dt><code>write_pdb</code></dt>
<dd><p class="startdd">The value of this keyword is boolean. If true a PDB file with the molecular coordinates will be written.</p>
<p class="enddd"></p>
</dd>
<dt><code>filename</code></dt>
<dd><p class="startdd">The value of this keyword is a string that gives a name from which checkpoint and other filenames are constructed. The default is the basename of the input file.</p>
<p class="enddd"></p>
</dd>
<dt><code>print_timings</code></dt>
<dd><p class="startdd">If this is true, timing information is printed at the end of the run. The default is true.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>There are also some utility keywords that tell mpqc some technical details about how to do the calculation: </p><dl>
<dt><code>debug</code></dt>
<dd>This optional keyword gives a Debugger object which can be used to help find the problem if MPQC encounters a catastrophic error. </dd>
<dt><code>matrixkit</code></dt>
<dd>This optional keyword gives a SCMatrixKit specialization which is used to produce matrices of the desired type. The default is a ReplSCMatrixKit which replicates matrices on all of the nodes. Other choices are not thoroughly tested. </dd>
</dl>
<h1><a class="anchor" id="mpqcoowalk"></a>
A Walk-Through of an Object-Oriented Input File</h1>
<p>This example input does a Hartree-Fock calculation on water. Following is the entire input, followed by a breakdown with descriptions.</p>
<pre>
% This input does a Hartree-Fock calculation on water.
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
  )
)
</pre><p> <br  />
</p>
<p>We start with a descriptive comment. Comments begin with a <code>%</code>. Everything from the <code>%</code> to the end of the line is ignored.</p>
<pre>
% This input does a Hartree-Fock calculation on water.
</pre><p> <br  />
</p>
<p>Now lets set up a Molecule object. The name of the object comes first, it is <code>molecule</code>. Then, in angle brackets, comes the type of the molecule, which is the class Molecule. The keyword and class name are followed by a <code>:</code> and then several pieces of input grouped between a pair of matching parentheses. These parentheses contain the information that will be given to Molecule KeyVal constructor.</p>
<pre>
molecule&lt;Molecule&gt;: (
</pre><p> <br  />
</p>
<p>The point group of the molecule is needed. This is done by assigning <code>symmetry</code> to a case insensitive Schoenflies symbol that is used to initialize a PointGroup object. An Abelian point group should be used.</p>
<pre>
  symmetry = C2V
</pre><p> <br  />
</p>
<p>The default unit for the Cartesian coordinates is Bohr. You can specify other units by assigned <code>unit</code> to a string that will be used to initialize a Units object.</p>
<pre>
  unit = angstrom
</pre><p> <br  />
</p>
<p>Finally, the atoms and coordinates are given. This can be given in the shorthand table syntax shown below. The headings of the table are the keywords between the first pair of brackets. These are followed by an <code>=</code> and another pair of brackets that contain the data. The first datum is assigned to the first element of the array that corresponds to the first heading, <code>atom</code>. The second datum is assigned to the first element of the array associated with the second heading, <code>geometry</code>, and so on. Here the second datum is actually a vector: the x, y and z coordinates of the first atom.</p>
<pre>
  { atoms                       geometry                   } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
</pre><p> <br  />
</p>
<p>Next, a basis set object is given.</p>
<pre>
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
</pre><p> <br  />
</p>
<p>Now we will give the main body of input. All the subsequent keywords will be grouped in the <code>mpqc</code> section of the input (that is, each keyword will be prefixed with <code>mpqc:</code>).</p>
<pre>
mpqc: (
</pre><p> <br  />
</p>
<p>Next we give the <code>mole</code> keyword which provides a specialization of the MolecularEnergy class. In this case we will do a closed-shell Hartree-Fock calculation. That is done with an object of type CLHF. The keywords that CLHF accepts are given with the documentation for the CLHF class, usually in the description of the <code>const RefKeyVal&amp;</code> constructor for the class. Also with the CLHF documentation is a list of parent classes. Each of the parent classes may also have input. This input is included with the rest of the input for the child class.</p>
<pre>
  mole&lt;CLHF&gt;: (
</pre><p> <br  />
</p>
<p>The next line specifies the molecule to be used. There are two things to note, first that this is actually a reference to complete molecule specification elsewhere in the input file. The <code>$</code> indicates that this is a reference and the keyword following the <code>$</code> is the actual location of the molecule. The <code>:</code> in front of the keyword means that the keyword is not relative to the current location in the input, but rather relative to the root of the tree of keywords. Thus, this line grabs the molecule that was specified above. The molecule object could have been placed here, but frequently it is necessary that several objects refer to the exact same object and this can only be done using references.</p>
<p>The second point is that if you look at the documentation for CLHF, you will see that it doesn't read <code>molecule</code> keyword. However, if you follow its parent classes up to MolecularEnergy, you'll find that <code>molecule</code> is indeed read.</p>
<pre>
    molecule = $:molecule
</pre><p> <br  />
</p>
<p>Just as we gave <code>molecule</code>, specify the basis set with the <code>basis</code> keyword as follows:</p>
<pre>
    basis = $:basis
</pre><p> <br  />
</p>
<p>Now we close off the parentheses we opened above and we are finished.</p>
<pre>
  )
)
</pre><p> <br  />
</p>
<h1><a class="anchor" id="mpqcoosamp"></a>
Sample Object-Oriented Input Files</h1>
<p>The easiest way to get started with mpqc is to start with one of sample inputs that most nearly matches your problem. The <code>src/bin/mpqc/samples</code> contains all of the sample inputs below:</p>
<ul>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamphf">Hartree-Fock Energy</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosampmp2">MP2 Energy</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosampmp2r12">MP2-R12 energy</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamphfopt">Hartree-Fock Optimization</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamphessopt">Optimization with a Computed Guess Hessian</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosampoptnewt">Optimization Using Newton's Method</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamphffreq">Hartree-Fock Frequencies</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosampcoor">Giving Coordinates and a Guess Hessian</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamphb">Optimization with a Hydrogen Bond</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosampfixopt">Fixed Coordinate Optimization</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosampts">Transition State Optimization</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamptshess">Transition State Optimization with a Computed Guess Hessian</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamphfckpt">Hartree-Fock energy with intermediate checkpointing</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosampmp2r12ckpt">MP2-R12 energy with intermediate checkpointing</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamphfgradfromwfn">HF gradient computed from a previously computed HF wave funtion</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosampmp2usinghfwfn">MP2 Energy computed using precomputed Hartree-Fock wave function</a> </li>
<li>
<a class="el" href="mpqcoo.html#mpqcoosamphfusingcca">CLHF energy using a CCA integrals component</a> </li>
</ul>
<h2><a class="anchor" id="mpqcoosamphf"></a>
Hartree-Fock Energy</h2>
<p>The following input will compute the Hartree-Fock energy of water.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosampmp2"></a>
MP2 Energy</h2>
<p>The following input will compute the MP2 energy of water.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;MBPT2&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    % reference wavefunction
    reference&lt;CLHF&gt;: (
      molecule = $:molecule
      basis = $:basis
      memory = 16000000
    )
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosampmp2r12"></a>
MP2-R12 energy</h2>
<p>The following will compute the MP2-R12 energy of water in standard approximation A' (MP2-R12/A').</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "cc-pVDZ"
  molecule = $:molecule
)
% auxiliary basis set specification
abasis&lt;GaussianBasisSet&gt;: (
  name = "aug-cc-pVDZ"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;MBPT2_R12&gt;: (
    molecule = $:molecule
    basis = $:basis
    aux_basis = $:abasis
    stdapprox = "A'"
    nfzc = 1
    memory = 16000000
    integrals&lt;IntegralCints&gt;:()
    % reference wavefunction
    reference&lt;CLHF&gt;: (
      molecule = $:molecule
      basis = $:basis
      memory = 16000000
      integrals&lt;IntegralCints&gt;:()
    )
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosamphfopt"></a>
Hartree-Fock Optimization</h2>
<p>The following input will optimize the geometry of water using the quasi-Newton method.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "6-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosamphessopt"></a>
Optimization with a Computed Guess Hessian</h2>
<p>The following input will optimize the geometry of water using the quasi-Newton method. The guess Hessian will be computed at a lower level of theory.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "6-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian&lt;FinDispMolecularHessian&gt;: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy&lt;CLHF&gt;: (
        molecule = $:molecule
        memory = 16000000
        basis&lt;GaussianBasisSet&gt;: (
          name = "3-21G"
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosampoptnewt"></a>
Optimization Using Newton's Method</h2>
<p>The following input will optimize the geometry of water using the Newton's method. The Hessian will be computed at each step in the optimization. However, Hessian recomputation is usually not worth the cost; try using the computed Hessian as a guess Hessian for a quasi-Newton method before resorting to a Newton optimization.</p>
<pre>
% Emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = c2v
  unit = angstrom
  { atoms geometry } = {
     O     [     0.00000000     0.00000000     0.36937294 ]
     H     [     0.78397590     0.00000000    -0.18468647 ]
     H     [    -0.78397590     0.00000000    -0.18468647 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "3-21G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  restart = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
  )
  do_energy = no
  do_gradient = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    coor = $..:coor
    guess_wavefunction&lt;CLHF&gt;: (
      molecule = $:molecule
      total_charge = 0
      basis&lt;GaussianBasisSet&gt;: (
        molecule = $:molecule
        name = "STO-3G"
      )
      memory = 16000000
    )
    hessian&lt;FinDispMolecularHessian&gt;: (
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
    )
  )
  optimize = yes
  % optimizer object for the molecular geometry
  opt&lt;NewtonOpt&gt;: (
    print_hessian = yes
    max_iterations = 20
    function = $..:mole
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosamphffreq"></a>
Hartree-Fock Frequencies</h2>
<p>The following input will compute Hartree-Fock frequencies by finite displacements. A thermodynamic analysis will also be performed. If optimization input is also provided, then the optimization will be run first, then the frequencies.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C1
  { atoms geometry } = {
    O     [  0.0000000000    0.0000000000    0.8072934188 ]
    H     [  1.4325589285    0.0000000000   -0.3941980761 ]
    H     [ -1.4325589285    0.0000000000   -0.3941980761 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
% vibrational frequency input
  freq&lt;MolecularFrequencies&gt;: (
    molecule = $:molecule
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosampcoor"></a>
Giving Coordinates and a Guess Hessian</h2>
<p>The following example shows several features that are really independent. The variable coordinates are explicitly given, rather than generated automatically. This is especially useful when a guess Hessian is to be provided, as it is here. This Hessian, as given by the user, is not complete and the QNewtonOpt object will fill in the missing values using a guess the Hessian provided by the MolecularEnergy object. Also, fixed coordinates are given in this sample input.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006    1.438 ]
      O    [ 0.123    3.193    0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
    % use these instead of generated coordinates
    variable&lt;SetIntCoor&gt;: [
      &lt;StreSimpleCo&gt;:( atoms = [ 2 5 ] )
      &lt;BendSimpleCo&gt;:( atoms = [ 2 5 4 ] )
      &lt;OutSimpleCo&gt;: ( atoms = [ 5 2 1 3 ] )
      &lt;SumIntCoor&gt;: (
        coor: [
          &lt;StreSimpleCo&gt;:( atoms = [ 1 2 ] )
          &lt;StreSimpleCo&gt;:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      &lt;SumIntCoor&gt;: (
        coor: [
          &lt;StreSimpleCo&gt;:( atoms = [ 4 5 ] )
          &lt;StreSimpleCo&gt;:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      &lt;BendSimpleCo&gt;:( atoms = [ 1 2 3 ] )
      &lt;BendSimpleCo&gt;:( atoms = [ 5 4 6 ] )
    ]
    % these are fixed by symmetry anyway,
    fixed&lt;SetIntCoor&gt;: [
      &lt;SumIntCoor&gt;: (
        coor: [
          &lt;StreSimpleCo&gt;:( atoms = [ 1 2 ] )
          &lt;StreSimpleCo&gt;:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      &lt;SumIntCoor&gt;: (
        coor: [
          &lt;StreSimpleCo&gt;:( atoms = [ 4 5 ] )
          &lt;StreSimpleCo&gt;:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      &lt;TorsSimpleCo&gt;:( atoms = [ 2 5 4 6] )
      &lt;OutSimpleCo&gt;:( atoms = [ 3 2 6 4 ] )
      &lt;OutSimpleCo&gt;:( atoms = [ 1 2 6 4 ] )
    ]
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
    % give a partial guess hessian in internal coordinates
    % the missing elements will be filled in automatically
    hessian = [
        [  0.0109261670 ]
        [ -0.0004214845    0.0102746106  ]
        [ -0.0008600592    0.0030051330    0.0043149957 ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
     ]
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosamphb"></a>
Optimization with a Hydrogen Bond</h2>
<p>The automatic internal coordinate generator will fail if it cannot find enough redundant internal coordinates. In this case, the internal coordinate generator must be explicitly created in the input and given extra connectivity information, as is shown below.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006    1.438 ]
      O    [ 0.123    3.193    0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    % give an internal coordinate generator that knows about the
    % hydrogen bond between atoms 2 and 5
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosampfixopt"></a>
Fixed Coordinate Optimization</h2>
<p>This example shows how to selectively fix internal coordinates in an optimization. Any number of linearly independent coordinates can be given. These coordinates must remain linearly independent throughout the optimization, a condition that might not hold since the coordinates can be nonlinear.</p>
<p>By default, the initial fixed coordinates' values are taken from the cartesian geometry given by the Molecule object; however, the molecule will be displaced to the internal coordinate values given with the fixed internal coordinates if have_fixed_values keyword is set to true, as shown in this example. In this case, the initial cartesian geometry should be reasonably close to the desired initial geometry and all of the variable coordinates will be frozen to their original values during the initial displacement.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.04 -0.69 -1.59 ]
    H [  3.04 -0.69  1.59 ]
    N [  2.09 -0.48 -0.00 ]
    C [ -0.58 -0.15  0.00 ]
    H [ -1.17  1.82  0.00 ]
    H [ -1.41 -1.04 -1.64 ]
    H [ -1.41 -1.04  1.64 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "3-21G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
    have_fixed_values = yes
    fixed&lt;SetIntCoor&gt;: [
      &lt;OutSimpleCo&gt;: ( value = -0.1
                       label = "N-inversion"
                       atoms = [4 3 2 1] )
      ]
  )
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    max_iterations = 20
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosampts"></a>
Transition State Optimization</h2>
<p>This example shows a transition state optimization of the N-inversion in <img class="formulaInl" alt="$\mathrm{CH}_3\mathrm{NH}_2$" src="form_0.png"/> using mode following. The initial geometry was obtained by doing a few fixed coordinate optimizations along the inversion coordinate.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.045436 -0.697438 -1.596748 ]
    H [  3.045436 -0.697438  1.596748 ]
    N [  2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798  0.000000 ]
    H [ -1.171620  1.822306  0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238  1.647529 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "3-21G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
    followed&lt;OutSimpleCo&gt; = [ "N-inversion" 4 3 2 1 ]
  )  
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt&lt;EFCOpt&gt;: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update&lt;PowellUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosamptshess"></a>
Transition State Optimization with a Computed Guess Hessian</h2>
<p>This example shows a transition state optimization of the N-inversion in <img class="formulaInl" alt="$\mathrm{CH}_3\mathrm{NH}_2$" src="form_0.png"/> using mode following. The initial geometry was obtained by doing a few fixed coordinate optimizations along the inversion coordinate. An approximate guess Hessian will be computed, which makes the optimiziation converge much faster in this case.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.045436 -0.697438 -1.596748 ]
    H [  3.045436 -0.697438  1.596748 ]
    N [  2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798  0.000000 ]
    H [ -1.171620  1.822306  0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238  1.647529 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "3-21G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
    followed&lt;OutSimpleCo&gt; = [ "N-inversion" 4 3 2 1 ]
  )  
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian&lt;FinDispMolecularHessian&gt;: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy&lt;CLHF&gt;: (
        molecule = $:molecule
        memory = 16000000
        basis&lt;GaussianBasisSet&gt;: (
          name = "3-21G"
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt&lt;EFCOpt&gt;: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update&lt;PowellUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosamphfckpt"></a>
Hartree-Fock energy with intermediate checkpointing</h2>
<p>The following two sections demonstrate how MPQC can be used to save the <code>mole</code> object periodically. This input will compute the Hartree-Fock energy of water while saving the <code>mole</code> object every 3 iterations.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = yes
  filename = "h2o-rhf-STO3G"
  checkpoint_freq = 3
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
)
</pre><p> <br  />
</p>
<p>The <code>mole</code> object will be saved to files named "h2o-rhf-STO3G.wfn.&lt;iter#&gt;.tmp" where &lt;iter#&gt; is the SCF iteration number (3, 6, etc.). Only the most recent file is kept, files from previous iterations are removed automatically. Keyword <code>filename</code> here is used to set the default file name prefix.</p>
<h2><a class="anchor" id="mpqcoosampmp2r12ckpt"></a>
MP2-R12 energy with intermediate checkpointing</h2>
<p>The following input will compute the MP2-R12 energy of water in standard approximation A' (MP2-R12/A') while saving the <code>mole</code> object at intermediate checkpoints.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "cc-pVDZ"
  molecule = $:molecule
)
% auxiliary basis set specification
abasis&lt;GaussianBasisSet&gt;: (
  name = "aug-cc-pVDZ"
  molecule = $:molecule
)
mpqc: (
  checkpoint = yes
  filename = "h2o-mp2r12ap-vdz-avdz"
  savestate = no
  % method for computing the molecule's energy
  mole&lt;MBPT2_R12&gt;: (
    molecule = $:molecule
    basis = $:basis
    aux_basis = $:abasis
    stdapprox = "A'"
    nfzc = 1
    memory = 16000000
    integrals&lt;IntegralCints&gt;:()
    % reference wavefunction
    reference&lt;CLHF&gt;: (
      molecule = $:molecule
      basis = $:basis
      memory = 16000000
      integrals&lt;IntegralCints&gt;:()
    )
  )
)
</pre><p> <br  />
</p>
<p>The <code>mole</code> object will be saved to a file named <code>h2o-mp2r12ap-vdz-avdz.wfn"</code>. Keyword <code>filename</code> here is used to set the default file name prefix. Objects of the <code>MBPT2_R12</code> type are checkpointed after the HF procedure, after the first integrals (SBS) transformation, and after the optional second (ABS) transformation.</p>
<h2><a class="anchor" id="mpqcoosamphfgradfromwfn"></a>
HF gradient computed from a previously computed HF wave funtion</h2>
<p>The following will illustrate how to reuse previously computed <code>MolecularEnergy</code> objects in subsequent computations. The first input computes Hartree-Fock energy for water and saves the <code>mole</code> object to file <code>h2o-rhf-sto3g.wfn</code>.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = yes
  filename = "h2o-rhf-sto3g"
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
)
</pre><p> <br  />
</p>
<p>The second input reuses the <code>mole</code> object from the previous run to compute the gradient of the Hartree-Fock energy.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
mpqc: (
  checkpoint = no
  savestate = no
  restart = yes
  restart_file = "h2o-rhf-sto3g.wfn"
  do_gradient = yes
)
</pre><p> <br  />
</p>
<h2><a class="anchor" id="mpqcoosampmp2usinghfwfn"></a>
MP2 Energy computed using precomputed Hartree-Fock wave function</h2>
<p>The following input will compute the MP2 energy of water using a saved Hartree-Fock wave function obtained using the first input from <a class="el" href="mpqcoo.html#mpqcoosamphfgradfromwfn">HF gradient computed from a previously computed HF wave funtion</a>.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
% wave function file object specification
wfnfile&lt;BcastStateInBin&gt;:file = "h2o-rhf-sto3g.wfn"
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;MBPT2&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    % reference wavefunction
    reference&lt;SavableStateProxy&gt;: (
      statein = $:wfnfile
      object = "CLHF"
    )
  )
)
</pre><p> <br  />
</p>
<p>Note that now object <code>reference</code> is of type <code>SavableStateProxy</code>, rather than <code>CLHF</code>. <code>SavableStateProxy</code> is a special object type that can be converted at runtime into the desired type (in this case, <code>CLHF</code>, as indicated by <code>object</code>).</p>
<h2><a class="anchor" id="mpqcoosamphfusingcca"></a>
CLHF energy using a CCA integrals component</h2>
<p>The following input will compute the CLHF energy of water using a CCA integrals component via the IntegralCCA adaptor class.</p>
<pre>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  % path to component libraries
  cca_path = /usr/local/lib/cca
  % sidl class names of components which will be instantiated
  cca_load = MPQC.IntegralEvaluatorFactory
  do_cca = yes
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    % cca integrals adaptor class
    integrals&lt;IntegralCCA&gt;: (
      molecule = $:molecule
      % integral buffer type
      integral_buffer = opaque
      % integral package
      integral_package = intv3
      % factory component sidl class name
      evaluator_factory = MPQC.IntegralEvaluatorFactory
    )
  )
)
</pre><p> <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<hr>
<address>
<small>
Generated at Sun Jan 26 2020 23:33:05 for <a
href="http://www.mpqc.org">MPQC</a>
2.3.1 using the documentation package <a
href="http://www.doxygen.org">Doxygen</a>
1.8.16.
</small>
</address>
</body>
</html>
