<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPQC: The Reference Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPQC
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Reference Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Reference Library provides a means to automatically free memory that is no longer needed.</p>
<ul>
<li>
<a class="el" href="ref.html#refintro">Introduction to Reference Counting</a> </li>
<li>
<a class="el" href="ref.html#refthread">Thread Safety of the Reference Counting Package</a> </li>
<li>
<a class="el" href="ref.html#refcust">Customizing the Reference Counting Package</a> </li>
<li>
<a class="el" href="ref.html#refexample">A Reference Example</a> </li>
</ul>
<h1><a class="anchor" id="refintro"></a>
Introduction to Reference Counting</h1>
<p>It is fairly easy in C++ to create a pointer to an object that actually references invalid memory. One common way to do this is to create an object with new and store that object's pointer. Then the pointer is given to another object's member function as an argument which keeps a copy of the pointer for future use. After the member function returns, the routine that originally created the object delete's it, not knowing that another object has since created a reference to the object. The result of using the delete'ed object is unpredictable and would likely be a program crash. It is up to the programmer to provide the logic necessary to avoid this problem. The programmer must also deal with the problem of calling to delete operator on any new'ed memory when it is no longer referenced.</p>
<p>Reference counting is one technique that can be applied to automate memory management. In this approach, a count of how many pointers point to an object is attached to that object. This count is managed by a smart pointer class which mimics the behavior of C++ pointers by providing <code>operator-&gt;()</code>. This class has a pointer to the reference counted object and increments the reference count of objects when they are assigned to it while decrementing the counts of the objects that are displaced by these assigments. The smart pointer class automatically delete's the object when its reference count drops to zero.</p>
<p>A deficiency of this method is that unreferenced circular lists are not automatically deleted. Circular list implementors must provide a mechanism to detect when the list is dereferenced and then break the list's circularity to let the automated reference mechanism finish the work.</p>
<p>The reference library provides smart pointers and a base class that can be used to maintain reference counts to objects. For an object to be reference counted its class must inherit from the RefCount class. This adds <code>sizeof(int)</code> bytes of overhead per object and makes the destructor virtual (so a vtable will be added to objects of the class, if there wasn't already a virtual member in the class).</p>
<p>The smart pointers that maintain the reference counts are provided by the Ref class template. A smart pointer to a class A which inherits from RefCount would have the type Ref.</p>
<h1><a class="anchor" id="refthread"></a>
Thread Safety of the Reference Counting Package</h1>
<p>The referencing counting package is thread-safe if the CPP macro REF_USE_LOCKS is defined to 1. This means that Ref's to a particular object can be created and reassigned and destroyed in different threads. However, the Ref's themselves are not thread-safe. For example, a static Ref cannot be simultaneously modified from multiple threads.</p>
<p>Because there is an overhead associated with locking access to an object's reference count, locking is not turned on by default, and, thus, making and deleting references to an object in multiple threads is not thread-safe by default. The RefCount::use_locks member is passed a bool value to turn locking on and off on a per object basis.</p>
<h1><a class="anchor" id="refcust"></a>
Customizing the Reference Counting Package</h1>
<p>The behaviour of the package can be modified at compile time with the following five macros, each of which should be undefined, 0, or 1:</p>
<dl>
<dt><code>REF_CHECK_STACK</code></dt>
<dd>If this is 1, referenced objects are checked to see if they reside on the stack, in which case storage for the object is not managed, if management is enabled. </dd>
<dt><code>REF_MANAGE</code></dt>
<dd>If this is 1, the unmanage member is enabled. </dd>
<dt><code>REF_CHECK_MAX_NREF</code></dt>
<dd>If this is 1, the reference count is checked before it is incremented to make sure it isn't too big. </dd>
<dt><code>REF_CHECK_MIN_NREF</code></dt>
<dd>If this is 1, the reference count is checked before it is decremented to make sure it isn't already zero. </dd>
<dt><code>REF_USE_LOCKS</code></dt>
<dd>If this is 1, modification of the reference count is locked to allow thread-safe execution. </dd>
</dl>
<p>If a macro is undefined, then the behaviour is architecture dependent&mdash;usually, the macro will be set to 1 in this case. For maximum efficiency and for normal operation after the program is debugged, compile with all of the above macros defined to zero. This can also be done by defining REF_OPTIMIZE.</p>
<p>An include file can be used to set these options as well. This has the advantage that dependency checking will force an automatic recompile of all affected files if the options change. This is done in the file <a class="el" href="scconfig_8h_source.html">scconfig.h</a>, which is produced by the automated configuration procedure.</p>
<p>Note that all source code that uses references must be compiled with the same value for REF_MANAGE. Changing this can change the storage layout and the interpretation of the reference count data.</p>
<h1><a class="anchor" id="refexample"></a>
A Reference Example</h1>
<p>Following is a simple example of how to manage memory with reference counts.</p>
<pre>
#include &lt;util/container/ref.h&gt;</pre><pre>class A: virtual public RefCount {};</pre><pre>class B: public A {};</pre><pre>int
main()
{
  Ref&lt;A&gt; a1(new A);
  Ref&lt;A&gt; a2;</pre><pre>  // Create another reference to the A object pointed to by a1.
  a2 = a1;</pre><pre>  // Make a2 refer to a new A object.
  a2 = new A;</pre><pre>  // a2 was the only reference to the second A object, so setting
  // a2 to the null object will cause the second A object to be
  // deleted.
  a2 = 0;</pre><pre>  Ref&lt;B&gt; b(new B);</pre><pre>  // An object of type Ref&lt;X&gt; can be assigned to an object of type
  // Ref&lt;Y&gt; as long as X* can be assigned to Y*.
  a1 = b;</pre><pre>  // An automatic dynamic cast can be done by using the left shift
  // operator.
  b &lt;&lt; a1;</pre><pre>  // The B object will be deleted here because all of the references
  // to it go out of scope and destroyed.
  return 0;
}
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<hr>
<address>
<small>
Generated at Sun Jan 26 2020 23:33:05 for <a
href="http://www.mpqc.org">MPQC</a>
2.3.1 using the documentation package <a
href="http://www.doxygen.org">Doxygen</a>
1.8.16.
</small>
</address>
</body>
</html>
