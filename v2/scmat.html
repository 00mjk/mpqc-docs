<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPQC: The Matrix Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPQC
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Matrix Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The scientific computing matrix library (SCMAT) is designed around a set of matrix abstractions that permit very general matrix implementations. This flexibility is needed to support diverse computing environments. For example, this library must support, at a minimum: simple matrices that provide efficient matrix computations in a uniprocessor environment, clusters of processors with enough memory to store all matrices connected by a relatively slow network (workstations on an LAN), clusters of processors with enough memory to store all matrices and a fast interconnect network (a massively parallel machine such as the Intel Paragon), and clusters of machines that don't have enough memory to hold entire matrices.</p>
<ul>
<li>
<a class="el" href="scmat.html#scmatover">Overview</a> </li>
<li>
<a class="el" href="scmat.html#scmatdim">Matrix Dimensions</a> </li>
<li>
<a class="el" href="scmat.html#scmatref">Matrix Reference Classes</a> </li>
<li>
<a class="el" href="scmat.html#scmatabstract">Abstract Matrix Classes</a> </li>
<li>
<a class="el" href="scmat.html#scmatstor">Matrix Storage</a> </li>
<li>
<a class="el" href="scmat.html#scmatop">Manipulating Matrix Elements with Element Operations</a> </li>
<li>
<a class="el" href="scmat.html#scmatopsp">SCElementOp Specializations</a> </li>
<li>
<a class="el" href="scmat.html#scmatlocal">Local Matrices</a> </li>
<li>
<a class="el" href="scmat.html#scmatrepl">Replicated Matrices</a> </li>
<li>
<a class="el" href="scmat.html#scmatdist">Distributed Matrices</a> </li>
<li>
<a class="el" href="scmat.html#scmatblocked">Blocked Matrices</a> </li>
</ul>
<h1><a class="anchor" id="scmatover"></a>
Overview</h1>
<p>The design of SCMAT differs from other object-oriented matrix packages in two important ways. First, the matrix classes are abstract base classes. No storage layout is defined and virtual function calls must be used to access individual matrix elements. This would have a negative performance impact if users needed to frequently access matrix elements. The interface to the matrix classes is hopefully rich enough to avoid individual matrix element access for any computationally significant task. The second major difference is that symmetric matrices do not inherit from matrices, etc. The SCMAT user must know whether a matrix is symmetric at all places it is used if any performance gain, by virtue of symmetry, is expected.</p>
<p>Dimension information is contained objects of the SCDimension type. In addition to the simple integer dimension, application specific blocking information can be provided. For example, in a quantum chemistry application, the dimension corresponding to the atomic orbital basis set will have block sizes that correspond to the shells. Dimensions are used to create new matrix or vector objects.</p>
<p>The primary abstract classes are SCMatrix, SymmSCMatrix, DiagSCMatrix, and SCVector. These represent matrices, symmetric matrices, diagonal matrices, and vectors, respectively. These abstract classes are specialized into groups of classes. For example, the locally stored matrix implementation specializes the abstract classes to LocalSCMatrix, LocalSymmSCMatrix, LocalDiagSCMatrix, LocalSCVector, LocalSCDimension, and LocalSCMatrixKit. These specializations are all designed to work with each other. However, a given specialization is incompatible with other matrix specializations. An attempt to multiply a local matrix by a distributed matrix would generate an error at runtime.</p>
<p>Since the different groups of classes do not interoperate, some mechanism of creating consistent specializations is needed. This is done with SCMatrixKit objects. SCMatrixKit is an abstract base type which has specializations that correspond to each group of the matrix specializations. It is used to create matrices and vectors from that group. For example, the DistSCMatrixKit is used to create objects of type DistSCMatrix, DistSymmSCMatrix, DistDiagSCMatrix, and DistSCVector.</p>
<p>The abstract matrix classes and their derivations are usually not directly used by SCMAT users. The most convenient classes to use are the smart pointer classes RefSCMatrix, RefSymmSCMatrix, RefDiagSCMatrix, and RefSCDimension. These classes respectively inherit from <a class="el" href="classsc_1_1Ref.html">Ref&lt;SCMatrix&gt;</a>, <a class="el" href="classsc_1_1Ref.html">Ref&lt;SymmSCMatrix&gt;</a>, <a class="el" href="classsc_1_1Ref.html">Ref&lt;DiagSCMatrix&gt;</a>, and <a class="el" href="classsc_1_1Ref.html">Ref&lt;SCDimension&gt;</a>, providing automatic memory management through reference counting. The smart pointer classes also have matrix operations such as operator *(), operator -(), and operator +() defined as members for convenience. These forward the operations to the contained matrix object. The smart pointer classes also simplify creation of matrices by providing constructors that take as arguments one or more RefSCDimension's and a Ref&lt;SCMatrixKit&gt;. These initialize the smart pointer to contain a new matrix with a specialization corresponding to that of the Ref&lt;SCMatrixKit&gt;. Matrix operations not provided by the smart pointer classes but present as member in the abstract classes can be accessed with operator-&gt;().</p>
<p>If a needed matrix operation is missing, mechanisms exist to add more general operations. Operations which only depend on individual elements of matrices can be provided by specializations of the SCElementOp class. Sometimes we need operations on matrices with identical dimensions that examine each element in one matrix along with the corresponding element from the other matrix. This is accomplished with SCElementOp2 for two matrices and with SCElementOp3 for three.</p>
<p>Other features of SCMAT include run-time type facilities and persistence. Castdown operations (type conversions from less to more derived objects) and other run-time type information are provided by the DescribedClass base class. Persistence is not provided by inheriting from SavableState base clase as is the case with many other classes in the SC class hierarchies, because it is necessary to save objects in an implementation independent manner. If a calculation checkpoints a matrix on a single processor machine and later is restarted on a multiprocessor machine the matrix would need to be restored as a different matrix specialization. This is handled by saving and restoring matrices' and vectors' data without reference to the specialization.</p>
<p>The following include files are provided by the matrix library:</p>
<dl>
<dt><code><a class="el" href="matrix_8h_source.html">matrix.h</a></code></dt>
<dd><p class="startdd">Usually, this is the only include file needed by users of matrices. It declares reference counting pointers to abstract matrices.</p>
<p class="interdd">If kit for a matrix must be created, or a member specific to an implementation is needed, then that implementation's header file must be included.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="elemop_8h_source.html">elemop.h</a></code></dt>
<dd><p class="startdd">This is the next most useful include file. It defines useful SCElementOp, SCElementOp2, and SCElementOp3 specializations.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="abstract_8h_source.html">abstract.h</a></code></dt>
<dd><p class="startdd">This include file contains the declarations for abstract classes that users do not usually need to see. These include SCDimension, SCMatrix, SymmSCMatrix, DiagSCMatrix, SCMatrixKit. This file is currently included by <a class="el" href="matrix_8h_source.html">matrix.h</a>.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="block_8h_source.html">block.h</a></code></dt>
<dd><p class="startdd">This file declares SCMatrixBlock and specializations. It only need be include by users implementing new SCElementOp specializations.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="blkiter_8h_source.html">blkiter.h</a></code></dt>
<dd><p class="startdd">This include file declares the implementations of SCMatrixBlockIter. It only need be include by users implementing new SCElementOp specializations.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="vector3_8h_source.html">vector3.h</a></code></dt>
<dd><p class="startdd">This declares SCVector3, a lightweight vector of length three.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="matrix3_8h_source.html">matrix3.h</a></code></dt>
<dd><p class="startdd">This declares SCMatrix3, a lightweight matrix of dimension three by three. It includes <a class="el" href="vector3_8h_source.html">vector3.h</a>.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="local_8h_source.html">local.h</a></code></dt>
<dd><p class="startdd">This include file is the matrix implementation for locally stored matrices. These are suitable for use in a uniprocessor environment. The LocalSCMatrixKit is the default matrix implementation returned by the static member SCMatrixKit::default_matrixkit. This file usually doesn't need to be included.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="dist_8h_source.html">dist.h</a></code></dt>
<dd><p class="startdd">This include file is the matrix implementation for distributed matrices. These are suitable for use in a distributed memory multiprocessor which does not have enough memory to hold all of the matrix elements on each processor. This file usually doesn't need to be included.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="repl_8h_source.html">repl.h</a></code></dt>
<dd><p class="startdd">This include file is the matrix implementation for replicated matrices. These are suitable for use in a distributed memory multiprocessor which does have enough memory to hold all of the matrix elements on each processor. This file usually doesn't need to be included.</p>
<p class="enddd"></p>
</dd>
<dt><code><a class="el" href="blocked_8h_source.html">blocked.h</a></code></dt>
<dd><p class="startdd">This include file is the matrix implementation for blocked matrices. Blocked matrices store a matrix as subblocks that are matrices from another matrix specialization. These are used to save storage and computation time in quantum chemistry applications for molecules with other than <img class="formulaInl" alt="$C_1$" src="form_10.png"/> point group symmetry.</p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="scmatdim"></a>
Matrix Dimensions</h1>
<p>In addition to the simple integer dimension, objects of the SCDimension class contain application specific blocking information. This information is held in an object of class SCBlockInfo.</p>
<h1><a class="anchor" id="scmatref"></a>
Matrix Reference Classes</h1>
<p>The easiest way to use SCMAT is through the smart pointer classes RefSCMatrix, RefSymmSCMatrix, RefDiagSCMatrix, RefSCVector, RefSCDimension, and Ref&lt;SCMatrixKit&gt;. These are based on the Ref reference counting package and automatically delete matrix objects when they are no longer needed. These reference classes also have common operations defined as members for convenience. This makes it unnecessary to also use the sometimes awkward syntax of operator-&gt;() to manipulate the contained objects.</p>
<h1><a class="anchor" id="scmatabstract"></a>
Abstract Matrix Classes</h1>
<p>This section documents the primary abstract classes: SCMatrix, SymmSCMatrix, DiagSCMatrix, and SCVector, as well as the SCMatrixKit class which allows the programmer to generate consistent specializations of matrices. These represent matrices, symmetric matrices, diagonal matrices, and vectors, respectively.</p>
<p>This section is primarily for implementers of new specializations of matrices. Users of existing matrices will be most interested in the matrix reference classes.</p>
<h1><a class="anchor" id="scmatstor"></a>
Matrix Storage</h1>
<p>All elements of matrices and vectors are kept in blocks. The choice of blocks and where they are keep is left up to each matrix specialization.</p>
<h1><a class="anchor" id="scmatop"></a>
Manipulating Matrix Elements with Element Operations</h1>
<p>The SCElementOp, SCElementOp2, and SCElementOp3 classes can be used to maniupulate matrix elements.</p>
<h1><a class="anchor" id="scmatopsp"></a>
SCElementOp Specializations</h1>
<p>Several commonly needed element operations are already coded up and available by including <a class="el" href="elemop_8h_source.html">math/scmat/elemop.h</a>. Below are descriptions of these classes:</p>
<dl>
<dt>SCElementScalarProduct</dt>
<dd>This SCElementOp2 computes the scalar product of two matrices or vectors. The result is available after the operation from the return value of the result() member. </dd>
<dt>SCDestructiveElementProduct</dt>
<dd>This SCElementOp2 replaces the elements of the matrix or vector whose element_op member is called. The resulting values are the element by element products of the two matrices or vectors. </dd>
<dt>SCElementScale</dt>
<dd>This scales each element by an amount given in the constructor. </dd>
<dt>SCElementRandomize</dt>
<dd>This generates random elements. </dd>
<dt>SCElementAssign</dt>
<dd>Assign to each element the value passed to the constructor. </dd>
<dt>SCElementSquareRoot</dt>
<dd>Replace each element with its square root. </dd>
<dt>SCElementInvert</dt>
<dd>Replace each element by its reciprocal. </dd>
<dt>SCElementScaleDiagonal</dt>
<dd>Scales the diagonal elements of a matrix by the argument passed to the constructor. Use of this on a vector is undefined. </dd>
<dt>SCElementShiftDiagonal</dt>
<dd>Add the value passed to the constructor to the diagonal elements of the matrix. Use of this on a vector is undefined. </dd>
<dt>SCElementMaxAbs</dt>
<dd>Find the maximum absolute value element in a matrix or vector. The result is available as the return value of the <code>result()</code> member. </dd>
<dt>SCElementDot</dt>
<dd>The constructor for this class takes three arguments: SCElementDot(double**a, double**b, int length). The length of each vector given by a and b is given by length. The number of vectors in a is the number of rows in the matrix and the number in b is the number of columns. To each element in the matrix <img class="formulaInl" alt="$m_{ij}$" src="form_63.png"/> the dot product of the <img class="formulaInl" alt="$a_i$" src="form_64.png"/> and <img class="formulaInl" alt="$b_j$" src="form_65.png"/> is added. </dd>
<dt>SCElementAccumulateSCMatrix</dt>
<dd>This is obsolete&mdash;do not use it. </dd>
<dt>SCElementAccumulateSymmSCMatrix</dt>
<dd>This is obsolete&mdash;do not use it. </dd>
<dt>SCElementAccumulateDiagSCMatrix</dt>
<dd>This is obsolete&mdash;do not use it. </dd>
<dt>SCElementAccumulateSCVector</dt>
<dd>This is obsolete&mdash;do not use it. </dd>
</dl>
<h1><a class="anchor" id="scmatlocal"></a>
Local Matrices</h1>
<p>Local matrices do no communication. All elements reside on each node and all computations are duplicated on each node.</p>
<h1><a class="anchor" id="scmatrepl"></a>
Replicated Matrices</h1>
<p>Replicated matrices hold all of the elements on each node, however do some communications in order to reduce computation time.</p>
<h1><a class="anchor" id="scmatdist"></a>
Distributed Matrices</h1>
<p>Distributed matrices spread the elements across all the nodes and thus require less storage than local matrices however these use more communications than replicated matrices.</p>
<h1><a class="anchor" id="scmatblocked"></a>
Blocked Matrices</h1>
<p>Blocked matrices are used to implement point group symmetry. Another matrix specialization is used to hold the diagonal subblocks of a matrix. The offdiagonal subblocks are known to be zero and not stored. This results in considerable savings in storage and computation for those cases where it applies. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<hr>
<address>
<small>
Generated at Sun Jan 26 2020 23:33:05 for <a
href="http://www.mpqc.org">MPQC</a>
2.3.1 using the documentation package <a
href="http://www.doxygen.org">Doxygen</a>
1.8.16.
</small>
</address>
</body>
</html>
