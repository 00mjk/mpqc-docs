<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPQC: sc::MemoryGrp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPQC
   &#160;<span id="projectnumber">3.0.0-alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsc_1_1MemoryGrp.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsc_1_1MemoryGrp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sc::MemoryGrp Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classsc_1_1MemoryGrp.html" title="The MemoryGrp abstract class provides a way of accessing distributed memory in a parallel machine.">MemoryGrp</a> abstract class provides a way of accessing distributed memory in a parallel machine.  
 <a href="classsc_1_1MemoryGrp.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory_8h_source.html">util/group/memory.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sc::MemoryGrp:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsc_1_1MemoryGrp.png" usemap="#sc::MemoryGrp_map" alt=""/>
  <map id="sc::MemoryGrp_map" name="sc::MemoryGrp_map">
<area href="classsc_1_1DescribedClass.html" title="Classes which need runtime information about themselves and their relationship to other classes can v..." alt="sc::DescribedClass" shape="rect" coords="168,56,326,80"/>
<area href="classsc_1_1RefCount.html" title="The base class for all reference counted objects." alt="sc::RefCount" shape="rect" coords="168,0,326,24"/>
<area href="classsc_1_1MemoryGrpRegion.html" title="The MemoryGrpRegion is a MemoryGrp proxy to a region of a MemoryGrp." alt="sc::MemoryGrpRegion" shape="rect" coords="0,168,158,192"/>
<area href="classsc_1_1MsgMemoryGrp.html" title="A MsgMemoryGrp that initializes its data using a messagegrp." alt="sc::MsgMemoryGrp" shape="rect" coords="168,168,326,192"/>
<area href="classsc_1_1ProcMemoryGrp.html" title="The ProcMemoryGrp concrete class provides an implementation of MemoryGrp for a single processor." alt="sc::ProcMemoryGrp" shape="rect" coords="336,168,494,192"/>
<area href="classsc_1_1ActiveMsgMemoryGrp.html" title="The ActiveMsgMemoryGrp abstract class specializes the MsgMemoryGrp class." alt="sc::ActiveMsgMemoryGrp" shape="rect" coords="0,224,158,248"/>
<area href="classsc_1_1RDMAMemoryGrp.html" title="The RDMAMemoryGrp abstract class specializes the MsgMemoryGrp class." alt="sc::RDMAMemoryGrp" shape="rect" coords="168,224,326,248"/>
<area href="classsc_1_1ShmMemoryGrp.html" title="The ShmMemoryGrp concrete class provides an implementation of MsgMemoryGrp." alt="sc::ShmMemoryGrp" shape="rect" coords="336,224,494,248"/>
<area href="classsc_1_1MTMPIMemoryGrp.html" title="This MemoryGrp class requires a MT-safe MPI implementation." alt="sc::MTMPIMemoryGrp" shape="rect" coords="0,280,158,304"/>
<area href="classsc_1_1ARMCIMemoryGrp.html" title="The ARMCIMemoryGrp concrete class provides an implementation of MsgMemoryGrp." alt="sc::ARMCIMemoryGrp" shape="rect" coords="168,280,326,304"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac173f8e0e4380b70c4c61e6b3d763c62"><td class="memItemLeft" align="right" valign="top"><a id="ac173f8e0e4380b70c4c61e6b3d763c62"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryGrp</b> (const <a class="el" href="classsc_1_1Ref.html">Ref</a>&lt; <a class="el" href="classsc_1_1KeyVal.html">KeyVal</a> &gt; &amp;)</td></tr>
<tr class="separator:ac173f8e0e4380b70c4c61e6b3d763c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ef2e7e8577c392d5966f52e1de2a99"><td class="memItemLeft" align="right" valign="top"><a id="a70ef2e7e8577c392d5966f52e1de2a99"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a70ef2e7e8577c392d5966f52e1de2a99">me</a> () const</td></tr>
<tr class="memdesc:a70ef2e7e8577c392d5966f52e1de2a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns who I am. <br /></td></tr>
<tr class="separator:a70ef2e7e8577c392d5966f52e1de2a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd89b510c82aa2696efb87e4e1538da"><td class="memItemLeft" align="right" valign="top"><a id="acfd89b510c82aa2696efb87e4e1538da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#acfd89b510c82aa2696efb87e4e1538da">n</a> () const</td></tr>
<tr class="memdesc:acfd89b510c82aa2696efb87e4e1538da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many nodes there are. <br /></td></tr>
<tr class="separator:acfd89b510c82aa2696efb87e4e1538da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee243438a21eb017e3f5f6624ab9cfc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a4ee243438a21eb017e3f5f6624ab9cfc">set_localsize</a> (size_t)=0</td></tr>
<tr class="memdesc:a4ee243438a21eb017e3f5f6624ab9cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of locally held memory.  <a href="classsc_1_1MemoryGrp.html#a4ee243438a21eb017e3f5f6624ab9cfc">More...</a><br /></td></tr>
<tr class="separator:a4ee243438a21eb017e3f5f6624ab9cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56426818b8a6d9b333e33ccdd23f32b"><td class="memItemLeft" align="right" valign="top"><a id="ae56426818b8a6d9b333e33ccdd23f32b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#ae56426818b8a6d9b333e33ccdd23f32b">localsize</a> ()</td></tr>
<tr class="memdesc:ae56426818b8a6d9b333e33ccdd23f32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of memory residing locally on <a class="el" href="classsc_1_1MemoryGrp.html#a70ef2e7e8577c392d5966f52e1de2a99" title="Returns who I am.">me()</a>. <br /></td></tr>
<tr class="separator:ae56426818b8a6d9b333e33ccdd23f32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc2e145860610b03e2e2af5417e74c8"><td class="memItemLeft" align="right" valign="top"><a id="addc2e145860610b03e2e2af5417e74c8"></a>
virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#addc2e145860610b03e2e2af5417e74c8">localdata</a> ()=0</td></tr>
<tr class="memdesc:addc2e145860610b03e2e2af5417e74c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the local data. <br /></td></tr>
<tr class="separator:addc2e145860610b03e2e2af5417e74c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2b088ce7904ec4cba6f40555a69833"><td class="memItemLeft" align="right" valign="top"><a id="aea2b088ce7904ec4cba6f40555a69833"></a>
distsize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#aea2b088ce7904ec4cba6f40555a69833">localoffset</a> ()</td></tr>
<tr class="memdesc:aea2b088ce7904ec4cba6f40555a69833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global offset to this node's memory. <br /></td></tr>
<tr class="separator:aea2b088ce7904ec4cba6f40555a69833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16856ef367eb8d9b39bb36525d7753bf"><td class="memItemLeft" align="right" valign="top"><a id="a16856ef367eb8d9b39bb36525d7753bf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a16856ef367eb8d9b39bb36525d7753bf">size</a> (int node)</td></tr>
<tr class="memdesc:a16856ef367eb8d9b39bb36525d7753bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of memory residing on node. <br /></td></tr>
<tr class="separator:a16856ef367eb8d9b39bb36525d7753bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65ac54b76c98942de3dcae3bb776e03"><td class="memItemLeft" align="right" valign="top"><a id="ac65ac54b76c98942de3dcae3bb776e03"></a>
distsize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#ac65ac54b76c98942de3dcae3bb776e03">offset</a> (int node)</td></tr>
<tr class="memdesc:ac65ac54b76c98942de3dcae3bb776e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global offset to node's memory. <br /></td></tr>
<tr class="separator:ac65ac54b76c98942de3dcae3bb776e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f900af5de88700224ed3cceecd1fc9"><td class="memItemLeft" align="right" valign="top"><a id="a70f900af5de88700224ed3cceecd1fc9"></a>
distsize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a70f900af5de88700224ed3cceecd1fc9">totalsize</a> ()</td></tr>
<tr class="memdesc:a70f900af5de88700224ed3cceecd1fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all memory allocated on all nodes. <br /></td></tr>
<tr class="separator:a70f900af5de88700224ed3cceecd1fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72903ddd45d1dd9deabb92970a81aec8"><td class="memItemLeft" align="right" valign="top"><a id="a72903ddd45d1dd9deabb92970a81aec8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a72903ddd45d1dd9deabb92970a81aec8">activate</a> ()</td></tr>
<tr class="memdesc:a72903ddd45d1dd9deabb92970a81aec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate is called before the memory is to be used. <br /></td></tr>
<tr class="separator:a72903ddd45d1dd9deabb92970a81aec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee66fcdd210e3d4670d5e2e4ae9c0755"><td class="memItemLeft" align="right" valign="top"><a id="aee66fcdd210e3d4670d5e2e4ae9c0755"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#aee66fcdd210e3d4670d5e2e4ae9c0755">deactivate</a> ()</td></tr>
<tr class="memdesc:aee66fcdd210e3d4670d5e2e4ae9c0755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate is called after the memory has been used. <br /></td></tr>
<tr class="separator:aee66fcdd210e3d4670d5e2e4ae9c0755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb8e205f88d6d179b932cbb9a2f3138"><td class="memItemLeft" align="right" valign="top"><a id="afcb8e205f88d6d179b932cbb9a2f3138"></a>
virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#afcb8e205f88d6d179b932cbb9a2f3138">obtain_writeonly</a> (distsize_t <a class="el" href="classsc_1_1MemoryGrp.html#ac65ac54b76c98942de3dcae3bb776e03">offset</a>, size_t <a class="el" href="classsc_1_1MemoryGrp.html#a16856ef367eb8d9b39bb36525d7753bf">size</a>)=0</td></tr>
<tr class="memdesc:afcb8e205f88d6d179b932cbb9a2f3138"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gives write access to the memory location. No locking is done. <br /></td></tr>
<tr class="separator:afcb8e205f88d6d179b932cbb9a2f3138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e22a3efa50e6be4d98d560d8b85d0a"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#aa2e22a3efa50e6be4d98d560d8b85d0a">obtain_readwrite</a> (distsize_t <a class="el" href="classsc_1_1MemoryGrp.html#ac65ac54b76c98942de3dcae3bb776e03">offset</a>, size_t <a class="el" href="classsc_1_1MemoryGrp.html#a16856ef367eb8d9b39bb36525d7753bf">size</a>)=0</td></tr>
<tr class="memdesc:aa2e22a3efa50e6be4d98d560d8b85d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only one thread can have an unreleased obtain_readwrite at a time.  <a href="classsc_1_1MemoryGrp.html#aa2e22a3efa50e6be4d98d560d8b85d0a">More...</a><br /></td></tr>
<tr class="separator:aa2e22a3efa50e6be4d98d560d8b85d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f7744e3c3a71489929b7ff7c570159"><td class="memItemLeft" align="right" valign="top"><a id="a09f7744e3c3a71489929b7ff7c570159"></a>
virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a09f7744e3c3a71489929b7ff7c570159">obtain_readonly</a> (distsize_t <a class="el" href="classsc_1_1MemoryGrp.html#ac65ac54b76c98942de3dcae3bb776e03">offset</a>, size_t <a class="el" href="classsc_1_1MemoryGrp.html#a16856ef367eb8d9b39bb36525d7753bf">size</a>)=0</td></tr>
<tr class="memdesc:a09f7744e3c3a71489929b7ff7c570159"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gives read access to the memory location. No locking is done. <br /></td></tr>
<tr class="separator:a09f7744e3c3a71489929b7ff7c570159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f13aa99909d4117eda3f285c15a736"><td class="memItemLeft" align="right" valign="top"><a id="a37f13aa99909d4117eda3f285c15a736"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a37f13aa99909d4117eda3f285c15a736">release_readonly</a> (void *data, distsize_t <a class="el" href="classsc_1_1MemoryGrp.html#ac65ac54b76c98942de3dcae3bb776e03">offset</a>, size_t <a class="el" href="classsc_1_1MemoryGrp.html#a16856ef367eb8d9b39bb36525d7753bf">size</a>)=0</td></tr>
<tr class="memdesc:a37f13aa99909d4117eda3f285c15a736"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called when read access is no longer needed. <br /></td></tr>
<tr class="separator:a37f13aa99909d4117eda3f285c15a736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72e67e1c876349096ac90298427cbd6"><td class="memItemLeft" align="right" valign="top"><a id="ab72e67e1c876349096ac90298427cbd6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#ab72e67e1c876349096ac90298427cbd6">release_writeonly</a> (void *data, distsize_t <a class="el" href="classsc_1_1MemoryGrp.html#ac65ac54b76c98942de3dcae3bb776e03">offset</a>, size_t <a class="el" href="classsc_1_1MemoryGrp.html#a16856ef367eb8d9b39bb36525d7753bf">size</a>)=0</td></tr>
<tr class="memdesc:ab72e67e1c876349096ac90298427cbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called when write access is no longer needed. <br /></td></tr>
<tr class="separator:ab72e67e1c876349096ac90298427cbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac500f1bc0ffa60be641715df44df35d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#ac500f1bc0ffa60be641715df44df35d3">release_readwrite</a> (void *data, distsize_t <a class="el" href="classsc_1_1MemoryGrp.html#ac65ac54b76c98942de3dcae3bb776e03">offset</a>, size_t <a class="el" href="classsc_1_1MemoryGrp.html#a16856ef367eb8d9b39bb36525d7753bf">size</a>)=0</td></tr>
<tr class="memdesc:ac500f1bc0ffa60be641715df44df35d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called when read/write access is no longer needed.  <a href="classsc_1_1MemoryGrp.html#ac500f1bc0ffa60be641715df44df35d3">More...</a><br /></td></tr>
<tr class="separator:ac500f1bc0ffa60be641715df44df35d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b4d6586fea20da5df42728225e55c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a40b4d6586fea20da5df42728225e55c1">write</a> (const void *data, distsize_t <a class="el" href="classsc_1_1MemoryGrp.html#ac65ac54b76c98942de3dcae3bb776e03">offset</a>, size_t <a class="el" href="classsc_1_1MemoryGrp.html#a16856ef367eb8d9b39bb36525d7753bf">size</a>)</td></tr>
<tr class="memdesc:a40b4d6586fea20da5df42728225e55c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to write data directly.  <a href="classsc_1_1MemoryGrp.html#a40b4d6586fea20da5df42728225e55c1">More...</a><br /></td></tr>
<tr class="separator:a40b4d6586fea20da5df42728225e55c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4c6f54dfacf293701804db2b8d1488"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a5c4c6f54dfacf293701804db2b8d1488">sum_reduction</a> (double *data, distsize_t doffset, size_t dsize)</td></tr>
<tr class="memdesc:a5c4c6f54dfacf293701804db2b8d1488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a sum reduction on double data.  <a href="classsc_1_1MemoryGrp.html#a5c4c6f54dfacf293701804db2b8d1488">More...</a><br /></td></tr>
<tr class="separator:a5c4c6f54dfacf293701804db2b8d1488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ab75cbfd6a8cafdfd82a70e0d49801"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a25ab75cbfd6a8cafdfd82a70e0d49801">sum_reduction_on_node</a> (double *data, size_t doffset, size_t dsize, int node=-1)</td></tr>
<tr class="memdesc:a25ab75cbfd6a8cafdfd82a70e0d49801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a sum reduction on double data localized to a single node.  <a href="classsc_1_1MemoryGrp.html#a25ab75cbfd6a8cafdfd82a70e0d49801">More...</a><br /></td></tr>
<tr class="separator:a25ab75cbfd6a8cafdfd82a70e0d49801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef395631d3e3b7fe740e28bb7d9f571"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a0ef395631d3e3b7fe740e28bb7d9f571">sync</a> ()=0</td></tr>
<tr class="memdesc:a0ef395631d3e3b7fe740e28bb7d9f571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes all the nodes.  <a href="classsc_1_1MemoryGrp.html#a0ef395631d3e3b7fe740e28bb7d9f571">More...</a><br /></td></tr>
<tr class="separator:a0ef395631d3e3b7fe740e28bb7d9f571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026f90c96fb4c9523327c4943005131c"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a026f90c96fb4c9523327c4943005131c">malloc_local</a> (size_t nbyte)</td></tr>
<tr class="memdesc:a026f90c96fb4c9523327c4943005131c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate data that will be accessed locally only.  <a href="classsc_1_1MemoryGrp.html#a026f90c96fb4c9523327c4943005131c">More...</a><br /></td></tr>
<tr class="separator:a026f90c96fb4c9523327c4943005131c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b90ff97772c146900fbd8fb8b7e53f"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#af1b90ff97772c146900fbd8fb8b7e53f">malloc_local_double</a> (size_t ndouble)</td></tr>
<tr class="memdesc:af1b90ff97772c146900fbd8fb8b7e53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate double data that will be accessed locally only.  <a href="classsc_1_1MemoryGrp.html#af1b90ff97772c146900fbd8fb8b7e53f">More...</a><br /></td></tr>
<tr class="separator:af1b90ff97772c146900fbd8fb8b7e53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf75ac51b9c03a68462b646c5e4ec9fd"><td class="memItemLeft" align="right" valign="top"><a id="adf75ac51b9c03a68462b646c5e4ec9fd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#adf75ac51b9c03a68462b646c5e4ec9fd">free_local</a> (void *&amp;data)</td></tr>
<tr class="memdesc:adf75ac51b9c03a68462b646c5e4ec9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free data that was allocated with malloc_local, and set the pointer to 0. <br /></td></tr>
<tr class="separator:adf75ac51b9c03a68462b646c5e4ec9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe183e9b9316523f5851af7ae29847c5"><td class="memItemLeft" align="right" valign="top"><a id="abe183e9b9316523f5851af7ae29847c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#abe183e9b9316523f5851af7ae29847c5">free_local_double</a> (double *&amp;data)</td></tr>
<tr class="memdesc:abe183e9b9316523f5851af7ae29847c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free data that was allocated with malloc_local_double, and set the pointer to 0 <br  />
 <br /></td></tr>
<tr class="separator:abe183e9b9316523f5851af7ae29847c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72d6e855cf5d1bc1eae03f690b1ac75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#af72d6e855cf5d1bc1eae03f690b1ac75">catchup</a> ()</td></tr>
<tr class="memdesc:af72d6e855cf5d1bc1eae03f690b1ac75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes outstanding requests.  <a href="classsc_1_1MemoryGrp.html#af72d6e855cf5d1bc1eae03f690b1ac75">More...</a><br /></td></tr>
<tr class="separator:af72d6e855cf5d1bc1eae03f690b1ac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a15acd510c8b2f9322fdb9e05423778"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsc_1_1Ref.html">Ref</a>&lt; <a class="el" href="classsc_1_1MemoryGrp.html">MemoryGrp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a3a15acd510c8b2f9322fdb9e05423778">clone</a> (void)</td></tr>
<tr class="memdesc:a3a15acd510c8b2f9322fdb9e05423778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of this <a class="el" href="classsc_1_1MemoryGrp.html" title="The MemoryGrp abstract class provides a way of accessing distributed memory in a parallel machine.">MemoryGrp</a> specialization that provides an independent communication context.  <a href="classsc_1_1MemoryGrp.html#a3a15acd510c8b2f9322fdb9e05423778">More...</a><br /></td></tr>
<tr class="separator:a3a15acd510c8b2f9322fdb9e05423778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f05e6ea14ed268337512f911b00908b"><td class="memItemLeft" align="right" valign="top"><a id="a7f05e6ea14ed268337512f911b00908b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a7f05e6ea14ed268337512f911b00908b">print</a> (std::ostream &amp;o=<a class="el" href="classsc_1_1ExEnv.html#a360216acd1f990e999c0ed46cb350b1f">ExEnv::out0</a>()) const</td></tr>
<tr class="memdesc:a7f05e6ea14ed268337512f911b00908b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out information about the object. <br /></td></tr>
<tr class="separator:a7f05e6ea14ed268337512f911b00908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsc_1_1DescribedClass"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsc_1_1DescribedClass')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsc_1_1DescribedClass.html">sc::DescribedClass</a></td></tr>
<tr class="memitem:af6e904e781e460d589378c12358591ef inherit pub_methods_classsc_1_1DescribedClass"><td class="memItemLeft" align="right" valign="top"><a id="af6e904e781e460d589378c12358591ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DescribedClass</b> (const <a class="el" href="classsc_1_1DescribedClass.html">DescribedClass</a> &amp;)</td></tr>
<tr class="separator:af6e904e781e460d589378c12358591ef inherit pub_methods_classsc_1_1DescribedClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9b5823b636cab835e39c6b24a3478a inherit pub_methods_classsc_1_1DescribedClass"><td class="memItemLeft" align="right" valign="top"><a id="a6f9b5823b636cab835e39c6b24a3478a"></a>
<a class="el" href="classsc_1_1DescribedClass.html">DescribedClass</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsc_1_1DescribedClass.html">DescribedClass</a> &amp;)</td></tr>
<tr class="separator:a6f9b5823b636cab835e39c6b24a3478a inherit pub_methods_classsc_1_1DescribedClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12725d4bdb2e6e1025d258e4b084e3c5 inherit pub_methods_classsc_1_1DescribedClass"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsc_1_1ClassDesc.html">ClassDesc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1DescribedClass.html#a12725d4bdb2e6e1025d258e4b084e3c5">class_desc</a> () const MPQC__NOEXCEPT</td></tr>
<tr class="memdesc:a12725d4bdb2e6e1025d258e4b084e3c5 inherit pub_methods_classsc_1_1DescribedClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the unique pointer to the <a class="el" href="classsc_1_1ClassDesc.html" title="This class is used to contain information about classes.">ClassDesc</a> corresponding to the given type_info object.  <a href="classsc_1_1DescribedClass.html#a12725d4bdb2e6e1025d258e4b084e3c5">More...</a><br /></td></tr>
<tr class="separator:a12725d4bdb2e6e1025d258e4b084e3c5 inherit pub_methods_classsc_1_1DescribedClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66d8a42d50bdba52d4706b806afb85e inherit pub_methods_classsc_1_1DescribedClass"><td class="memItemLeft" align="right" valign="top"><a id="af66d8a42d50bdba52d4706b806afb85e"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1DescribedClass.html#af66d8a42d50bdba52d4706b806afb85e">class_name</a> () const</td></tr>
<tr class="memdesc:af66d8a42d50bdba52d4706b806afb85e inherit pub_methods_classsc_1_1DescribedClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the object's exact type. <br /></td></tr>
<tr class="separator:af66d8a42d50bdba52d4706b806afb85e inherit pub_methods_classsc_1_1DescribedClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff2db4d22163ecce3fbf45cca5ec291 inherit pub_methods_classsc_1_1DescribedClass"><td class="memItemLeft" align="right" valign="top"><a id="a8ff2db4d22163ecce3fbf45cca5ec291"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1DescribedClass.html#a8ff2db4d22163ecce3fbf45cca5ec291">class_version</a> () const</td></tr>
<tr class="memdesc:a8ff2db4d22163ecce3fbf45cca5ec291 inherit pub_methods_classsc_1_1DescribedClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the version of the class. <br /></td></tr>
<tr class="separator:a8ff2db4d22163ecce3fbf45cca5ec291 inherit pub_methods_classsc_1_1DescribedClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5484ed61b6662d1b2369d0f5cdee926c inherit pub_methods_classsc_1_1DescribedClass"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsc_1_1Ref.html">Ref</a>&lt; <a class="el" href="classsc_1_1DescribedClass.html">DescribedClass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1DescribedClass.html#a5484ed61b6662d1b2369d0f5cdee926c">ref</a> ()</td></tr>
<tr class="memdesc:a5484ed61b6662d1b2369d0f5cdee926c inherit pub_methods_classsc_1_1DescribedClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this object wrapped up in a <a class="el" href="classsc_1_1Ref.html" title="A template class that maintains references counts.">Ref</a> smart pointer.  <a href="classsc_1_1DescribedClass.html#a5484ed61b6662d1b2369d0f5cdee926c">More...</a><br /></td></tr>
<tr class="separator:a5484ed61b6662d1b2369d0f5cdee926c inherit pub_methods_classsc_1_1DescribedClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsc_1_1RefCount"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsc_1_1RefCount')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsc_1_1RefCount.html">sc::RefCount</a></td></tr>
<tr class="memitem:ad38752f89fcd35be43b8d20e71b0b5f7 inherit pub_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1RefCount.html#ad38752f89fcd35be43b8d20e71b0b5f7">identifier</a> () const</td></tr>
<tr class="memdesc:ad38752f89fcd35be43b8d20e71b0b5f7 inherit pub_methods_classsc_1_1RefCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unique identifier for this object that can be compared for different objects of different types.  <a href="classsc_1_1RefCount.html#ad38752f89fcd35be43b8d20e71b0b5f7">More...</a><br /></td></tr>
<tr class="separator:ad38752f89fcd35be43b8d20e71b0b5f7 inherit pub_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b586e6aff0dd7e5876af5af3f025b5 inherit pub_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top"><a id="a35b586e6aff0dd7e5876af5af3f025b5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1RefCount.html#a35b586e6aff0dd7e5876af5af3f025b5">lock_ptr</a> () const</td></tr>
<tr class="memdesc:a35b586e6aff0dd7e5876af5af3f025b5 inherit pub_methods_classsc_1_1RefCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock this object. <br /></td></tr>
<tr class="separator:a35b586e6aff0dd7e5876af5af3f025b5 inherit pub_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3019f1a229e2e398190f0764157f2f5f inherit pub_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top"><a id="a3019f1a229e2e398190f0764157f2f5f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1RefCount.html#a3019f1a229e2e398190f0764157f2f5f">unlock_ptr</a> () const</td></tr>
<tr class="memdesc:a3019f1a229e2e398190f0764157f2f5f inherit pub_methods_classsc_1_1RefCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock this object. <br /></td></tr>
<tr class="separator:a3019f1a229e2e398190f0764157f2f5f inherit pub_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05189b4c9aff106cef46f1b4c00211a inherit pub_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top"><a id="af05189b4c9aff106cef46f1b4c00211a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1RefCount.html#af05189b4c9aff106cef46f1b4c00211a">use_locks</a> (bool inVal)</td></tr>
<tr class="memdesc:af05189b4c9aff106cef46f1b4c00211a inherit pub_methods_classsc_1_1RefCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">start and stop using locks on this object <br /></td></tr>
<tr class="separator:af05189b4c9aff106cef46f1b4c00211a inherit pub_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7b6a205eb9882362594f058f90783d inherit pub_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top"><a id="a6f7b6a205eb9882362594f058f90783d"></a>
refcount_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1RefCount.html#a6f7b6a205eb9882362594f058f90783d">nreference</a> () const</td></tr>
<tr class="memdesc:a6f7b6a205eb9882362594f058f90783d inherit pub_methods_classsc_1_1RefCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference count. <br /></td></tr>
<tr class="separator:a6f7b6a205eb9882362594f058f90783d inherit pub_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10326b12fc26912be4a78f1e709d16da inherit pub_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top"><a id="a10326b12fc26912be4a78f1e709d16da"></a>
refcount_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1RefCount.html#a10326b12fc26912be4a78f1e709d16da">reference</a> ()</td></tr>
<tr class="memdesc:a10326b12fc26912be4a78f1e709d16da inherit pub_methods_classsc_1_1RefCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count and return the new count. <br /></td></tr>
<tr class="separator:a10326b12fc26912be4a78f1e709d16da inherit pub_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae391eb4734abf89fde3475bc9b013243 inherit pub_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top"><a id="ae391eb4734abf89fde3475bc9b013243"></a>
refcount_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1RefCount.html#ae391eb4734abf89fde3475bc9b013243">dereference</a> ()</td></tr>
<tr class="memdesc:ae391eb4734abf89fde3475bc9b013243 inherit pub_methods_classsc_1_1RefCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count and return the new count. <br /></td></tr>
<tr class="separator:ae391eb4734abf89fde3475bc9b013243 inherit pub_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab462600f4f273d4f0ba3d96fca6c6d4f inherit pub_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top"><a id="ab462600f4f273d4f0ba3d96fca6c6d4f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>managed</b> () const</td></tr>
<tr class="separator:ab462600f4f273d4f0ba3d96fca6c6d4f inherit pub_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ae4f1d5308822563eeafd0bdec0713 inherit pub_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1RefCount.html#ae1ae4f1d5308822563eeafd0bdec0713">unmanage</a> ()</td></tr>
<tr class="memdesc:ae1ae4f1d5308822563eeafd0bdec0713 inherit pub_methods_classsc_1_1RefCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off the reference counting mechanism for this object.  <a href="classsc_1_1RefCount.html#ae1ae4f1d5308822563eeafd0bdec0713">More...</a><br /></td></tr>
<tr class="separator:ae1ae4f1d5308822563eeafd0bdec0713 inherit pub_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a49c0712144fb5f38997678f833122ca4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsc_1_1MemoryGrp.html">MemoryGrp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a49c0712144fb5f38997678f833122ca4">initial_memorygrp</a> (int &amp;argc, char **argv)</td></tr>
<tr class="memdesc:a49c0712144fb5f38997678f833122ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a memory group.  <a href="classsc_1_1MemoryGrp.html#a49c0712144fb5f38997678f833122ca4">More...</a><br /></td></tr>
<tr class="separator:a49c0712144fb5f38997678f833122ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462844e2059e32da984cfcb331d97ba8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsc_1_1MemoryGrp.html">MemoryGrp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a462844e2059e32da984cfcb331d97ba8">initial_memorygrp</a> ()</td></tr>
<tr class="memdesc:a462844e2059e32da984cfcb331d97ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a memory group.  <a href="classsc_1_1MemoryGrp.html#a462844e2059e32da984cfcb331d97ba8">More...</a><br /></td></tr>
<tr class="separator:a462844e2059e32da984cfcb331d97ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fdf83fb404c5f1c5b0daab4bc0b3ff"><td class="memItemLeft" align="right" valign="top"><a id="a41fdf83fb404c5f1c5b0daab4bc0b3ff"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a41fdf83fb404c5f1c5b0daab4bc0b3ff">set_default_memorygrp</a> (const <a class="el" href="classsc_1_1Ref.html">Ref</a>&lt; <a class="el" href="classsc_1_1MemoryGrp.html">MemoryGrp</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a41fdf83fb404c5f1c5b0daab4bc0b3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default memory group contains the primary memory group to be used by an application. <br /></td></tr>
<tr class="separator:a41fdf83fb404c5f1c5b0daab4bc0b3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e239959d75cf50d70e525224587732"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsc_1_1MemoryGrp.html">MemoryGrp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsc_1_1MemoryGrp.html#a00e239959d75cf50d70e525224587732">get_default_memorygrp</a> ()</td></tr>
<tr class="memdesc:a00e239959d75cf50d70e525224587732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default memory group.  <a href="classsc_1_1MemoryGrp.html#a00e239959d75cf50d70e525224587732">More...</a><br /></td></tr>
<tr class="separator:a00e239959d75cf50d70e525224587732"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9594848a66c69206cdf6643fc88173d7"><td class="memItemLeft" align="right" valign="top"><a id="a9594848a66c69206cdf6643fc88173d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>obtain_local_lock</b> (size_t start, size_t fence)</td></tr>
<tr class="separator:a9594848a66c69206cdf6643fc88173d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb34d3e09158f4b0aaf5e820cb93810"><td class="memItemLeft" align="right" valign="top"><a id="acbb34d3e09158f4b0aaf5e820cb93810"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>release_local_lock</b> (size_t start, size_t fence)</td></tr>
<tr class="separator:acbb34d3e09158f4b0aaf5e820cb93810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsc_1_1RefCount"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classsc_1_1RefCount')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsc_1_1RefCount.html">sc::RefCount</a></td></tr>
<tr class="memitem:a2b3e81aa10e4ffd48fddca1a02203897 inherit pro_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top"><a id="a2b3e81aa10e4ffd48fddca1a02203897"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RefCount</b> (const <a class="el" href="classsc_1_1RefCount.html">RefCount</a> &amp;)</td></tr>
<tr class="separator:a2b3e81aa10e4ffd48fddca1a02203897 inherit pro_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5db1a70575be2487e770c6f838e533 inherit pro_methods_classsc_1_1RefCount"><td class="memItemLeft" align="right" valign="top"><a id="afa5db1a70575be2487e770c6f838e533"></a>
<a class="el" href="classsc_1_1RefCount.html">RefCount</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsc_1_1RefCount.html">RefCount</a> &amp;)</td></tr>
<tr class="separator:afa5db1a70575be2487e770c6f838e533 inherit pro_methods_classsc_1_1RefCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2491de5b7679913574eba6ae2d0dbb88"><td class="memItemLeft" align="right" valign="top"><a id="a2491de5b7679913574eba6ae2d0dbb88"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>me_</b></td></tr>
<tr class="separator:a2491de5b7679913574eba6ae2d0dbb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c9d235c519f4092908b550cb058181"><td class="memItemLeft" align="right" valign="top"><a id="a16c9d235c519f4092908b550cb058181"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>n_</b></td></tr>
<tr class="separator:a16c9d235c519f4092908b550cb058181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09a3a6591fd8f2e3521f61c346a3090"><td class="memItemLeft" align="right" valign="top"><a id="ac09a3a6591fd8f2e3521f61c346a3090"></a>
distsize_t *&#160;</td><td class="memItemRight" valign="bottom"><b>offsets_</b></td></tr>
<tr class="separator:ac09a3a6591fd8f2e3521f61c346a3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921e38186ab83a348f6b628d6c529b94"><td class="memItemLeft" align="right" valign="top"><a id="a921e38186ab83a348f6b628d6c529b94"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>debug_</b></td></tr>
<tr class="separator:a921e38186ab83a348f6b628d6c529b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classsc_1_1MemoryGrp.html" title="The MemoryGrp abstract class provides a way of accessing distributed memory in a parallel machine.">MemoryGrp</a> abstract class provides a way of accessing distributed memory in a parallel machine. </p>
<p>Several specializations are available. For one processor, <a class="el" href="classsc_1_1ProcMemoryGrp.html" title="The ProcMemoryGrp concrete class provides an implementation of MemoryGrp for a single processor.">ProcMemoryGrp</a> provides a simple stub implementation. Parallel specializations include <a class="el" href="classsc_1_1ShmMemoryGrp.html" title="The ShmMemoryGrp concrete class provides an implementation of MsgMemoryGrp.">ShmMemoryGrp</a>, <a class="el" href="classsc_1_1MTMPIMemoryGrp.html" title="This MemoryGrp class requires a MT-safe MPI implementation.">MTMPIMemoryGrp</a>, and <a class="el" href="classsc_1_1ARMCIMemoryGrp.html" title="The ARMCIMemoryGrp concrete class provides an implementation of MsgMemoryGrp.">ARMCIMemoryGrp</a>. The particular specializations that work depend highly on the target hardware and software environment. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af72d6e855cf5d1bc1eae03f690b1ac75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72d6e855cf5d1bc1eae03f690b1ac75">&#9670;&nbsp;</a></span>catchup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sc::MemoryGrp::catchup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes outstanding requests. </p>
<p>Some memory group implementations don't have access to real shared memory or even active messages. Instead, requests are processed whenever certain memory group routines are called. This can cause large latencies and buffer overflows. If this is a problem, then the catchup member can be called to process all outstanding requests. </p>

<p>Reimplemented in <a class="el" href="classsc_1_1MemoryGrpRegion.html#abd57deb0aa0a87b9bcc9c123b6d9a40a">sc::MemoryGrpRegion</a>.</p>

</div>
</div>
<a id="a3a15acd510c8b2f9322fdb9e05423778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a15acd510c8b2f9322fdb9e05423778">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsc_1_1Ref.html">Ref</a>&lt;<a class="el" href="classsc_1_1MemoryGrp.html">MemoryGrp</a>&gt; sc::MemoryGrp::clone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of this <a class="el" href="classsc_1_1MemoryGrp.html" title="The MemoryGrp abstract class provides a way of accessing distributed memory in a parallel machine.">MemoryGrp</a> specialization that provides an independent communication context. </p>
<p>This will throw for specializations that do not reimplement it. </p>

<p>Reimplemented in <a class="el" href="classsc_1_1MTMPIMemoryGrp.html#a81664d7125befca066dbe202689855b9">sc::MTMPIMemoryGrp</a>, and <a class="el" href="classsc_1_1MemoryGrpRegion.html#af7884e73f526889a37458f0073a92eae">sc::MemoryGrpRegion</a>.</p>

</div>
</div>
<a id="a00e239959d75cf50d70e525224587732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e239959d75cf50d70e525224587732">&#9670;&nbsp;</a></span>get_default_memorygrp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsc_1_1MemoryGrp.html">MemoryGrp</a>* sc::MemoryGrp::get_default_memorygrp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default memory group. </p>
<p>If the default memory group has not yet been set, then one is created. The particular specialization used is determined by configuration options and which specializations are being used for <a class="el" href="classsc_1_1MessageGrp.html" title="The MessageGrp abstract class provides a mechanism for moving data and objects between nodes in a par...">MessageGrp</a> and <a class="el" href="classsc_1_1ThreadGrp.html" title="The ThreadGrp abstract class provides a means to manage separate threads of control.">ThreadGrp</a>. </p>

</div>
</div>
<a id="a462844e2059e32da984cfcb331d97ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462844e2059e32da984cfcb331d97ba8">&#9670;&nbsp;</a></span>initial_memorygrp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsc_1_1MemoryGrp.html">MemoryGrp</a>* sc::MemoryGrp::initial_memorygrp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a memory group. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsc_1_1MemoryGrp.html#a49c0712144fb5f38997678f833122ca4" title="Create a memory group.">initial_memorygrp(int&amp;,char**)</a> </dd></dl>

</div>
</div>
<a id="a49c0712144fb5f38997678f833122ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c0712144fb5f38997678f833122ca4">&#9670;&nbsp;</a></span>initial_memorygrp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsc_1_1MemoryGrp.html">MemoryGrp</a>* sc::MemoryGrp::initial_memorygrp </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a memory group. </p>
<p>This routine looks for a -memorygrp argument, and then the environmental variable MEMORYGRP to decide which specialization of <a class="el" href="classsc_1_1MemoryGrp.html" title="The MemoryGrp abstract class provides a way of accessing distributed memory in a parallel machine.">MemoryGrp</a> would be appropriate. The argument to -memorygrp or the value of the environmental variable should be either string for a <a class="el" href="classsc_1_1ParsedKeyVal.html">ParsedKeyVal</a> constructor or a classname. The default <a class="el" href="classsc_1_1ThreadGrp.html" title="The ThreadGrp abstract class provides a means to manage separate threads of control.">ThreadGrp</a> and <a class="el" href="classsc_1_1MessageGrp.html" title="The MessageGrp abstract class provides a mechanism for moving data and objects between nodes in a par...">MessageGrp</a> objects should be initialized before this is called. </p>

</div>
</div>
<a id="a026f90c96fb4c9523327c4943005131c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026f90c96fb4c9523327c4943005131c">&#9670;&nbsp;</a></span>malloc_local()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* sc::MemoryGrp::malloc_local </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbyte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate data that will be accessed locally only. </p>
<p>Using this for data that will be used for global operations can improve efficiency. Data allocated in this way must be freed with free_local_double. <br  />
 </p>

<p>Reimplemented in <a class="el" href="classsc_1_1MemoryGrpRegion.html#af106f91caf069bc627207901088bcaed">sc::MemoryGrpRegion</a>, and <a class="el" href="classsc_1_1ARMCIMemoryGrp.html#aae4c0f8a771a059a3f019e42df64313e">sc::ARMCIMemoryGrp</a>.</p>

</div>
</div>
<a id="af1b90ff97772c146900fbd8fb8b7e53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b90ff97772c146900fbd8fb8b7e53f">&#9670;&nbsp;</a></span>malloc_local_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* sc::MemoryGrp::malloc_local_double </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ndouble</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate double data that will be accessed locally only. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsc_1_1MemoryGrp.html#a026f90c96fb4c9523327c4943005131c" title="Allocate data that will be accessed locally only.">malloc_local</a> </dd></dl>

</div>
</div>
<a id="aa2e22a3efa50e6be4d98d560d8b85d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e22a3efa50e6be4d98d560d8b85d0a">&#9670;&nbsp;</a></span>obtain_readwrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* sc::MemoryGrp::obtain_readwrite </td>
          <td>(</td>
          <td class="paramtype">distsize_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only one thread can have an unreleased obtain_readwrite at a time. </p>
<p>The actual memory region locked can be larger than that requested. If the memory region is already locked this will block. For this reason, data should be held as read/write for as short a time as possible. </p>

<p>Implemented in <a class="el" href="classsc_1_1ActiveMsgMemoryGrp.html#a3033ef9839a2c0b51385140d9319fe9e">sc::ActiveMsgMemoryGrp</a>, <a class="el" href="classsc_1_1ShmMemoryGrp.html#a9582f4500c153ef7848bfb44cd75a918">sc::ShmMemoryGrp</a>, <a class="el" href="classsc_1_1RDMAMemoryGrp.html#adf715164867d3a914b9d645c305dc381">sc::RDMAMemoryGrp</a>, <a class="el" href="classsc_1_1MemoryGrpRegion.html#a61324dd59864692a81723fee9ea5fbf0">sc::MemoryGrpRegion</a>, and <a class="el" href="classsc_1_1ProcMemoryGrp.html#abc6d9022cc235ee2e3d91de7a3870dc3">sc::ProcMemoryGrp</a>.</p>

</div>
</div>
<a id="ac500f1bc0ffa60be641715df44df35d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac500f1bc0ffa60be641715df44df35d3">&#9670;&nbsp;</a></span>release_readwrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sc::MemoryGrp::release_readwrite </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distsize_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called when read/write access is no longer needed. </p>
<p>The memory will be unlocked. </p>

<p>Implemented in <a class="el" href="classsc_1_1ActiveMsgMemoryGrp.html#a780d4589102538103061bf752421550e">sc::ActiveMsgMemoryGrp</a>, <a class="el" href="classsc_1_1ShmMemoryGrp.html#acb26ef4d48d1c98f4342ea9208186328">sc::ShmMemoryGrp</a>, <a class="el" href="classsc_1_1RDMAMemoryGrp.html#ae7d1459b315937a0f005388a14e022e5">sc::RDMAMemoryGrp</a>, <a class="el" href="classsc_1_1MemoryGrpRegion.html#a1b289c49d23f2963044b769439d864cf">sc::MemoryGrpRegion</a>, and <a class="el" href="classsc_1_1ProcMemoryGrp.html#a1a4149e36ee13adb10a31727dc3903a9">sc::ProcMemoryGrp</a>.</p>

</div>
</div>
<a id="a4ee243438a21eb017e3f5f6624ab9cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee243438a21eb017e3f5f6624ab9cfc">&#9670;&nbsp;</a></span>set_localsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sc::MemoryGrp::set_localsize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of locally held memory. </p>
<p>When memory is accessed using a global offset counting starts at node 0 and proceeds up to node <a class="el" href="classsc_1_1MemoryGrp.html#acfd89b510c82aa2696efb87e4e1538da" title="Returns how many nodes there are.">n()</a> - 1. </p>

<p>Implemented in <a class="el" href="classsc_1_1ActiveMsgMemoryGrp.html#a60953da3be5901a6f90fff5a80e028b3">sc::ActiveMsgMemoryGrp</a>, <a class="el" href="classsc_1_1ShmMemoryGrp.html#aed4877a530a377d18ad6ea8529f9866c">sc::ShmMemoryGrp</a>, <a class="el" href="classsc_1_1MemoryGrpRegion.html#ade7a29420f8faa62fbc7252812623083">sc::MemoryGrpRegion</a>, <a class="el" href="classsc_1_1ARMCIMemoryGrp.html#a8d0b5d860b35b2510ddb2a4b88ef2503">sc::ARMCIMemoryGrp</a>, <a class="el" href="classsc_1_1ProcMemoryGrp.html#a056878e285deaac6953288e517254b0f">sc::ProcMemoryGrp</a>, <a class="el" href="classsc_1_1RDMAMemoryGrp.html#a49c353380e4629ae9222bda6708e5524">sc::RDMAMemoryGrp</a>, and <a class="el" href="classsc_1_1MsgMemoryGrp.html#a902db59bfb4f13979efa58b7d9077b53">sc::MsgMemoryGrp</a>.</p>

</div>
</div>
<a id="a5c4c6f54dfacf293701804db2b8d1488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4c6f54dfacf293701804db2b8d1488">&#9670;&nbsp;</a></span>sum_reduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sc::MemoryGrp::sum_reduction </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distsize_t&#160;</td>
          <td class="paramname"><em>doffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a sum reduction on double data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the contribution to sum into the global array. </td></tr>
    <tr><td class="paramname">doffset</td><td>the global offset in terms of doubles. </td></tr>
    <tr><td class="paramname">dsize</td><td>the size in terms of doubles. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsc_1_1ActiveMsgMemoryGrp.html#a8a7de475e77b7b0a447ca4713277a02c">sc::ActiveMsgMemoryGrp</a>, and <a class="el" href="classsc_1_1RDMAMemoryGrp.html#a93d1bcacdc352c01a33691ebbcab3b7b">sc::RDMAMemoryGrp</a>.</p>

</div>
</div>
<a id="a25ab75cbfd6a8cafdfd82a70e0d49801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ab75cbfd6a8cafdfd82a70e0d49801">&#9670;&nbsp;</a></span>sum_reduction_on_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sc::MemoryGrp::sum_reduction_on_node </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>doffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a sum reduction on double data localized to a single node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the contribution to sum into the global array. </td></tr>
    <tr><td class="paramname">doffset</td><td>the local offset on the node in terms of doubles. </td></tr>
    <tr><td class="paramname">dsize</td><td>the size in terms of doubles. </td></tr>
    <tr><td class="paramname">node</td><td>the node holding the data. The default is the local node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsc_1_1ActiveMsgMemoryGrp.html#a8ac9a91e4c59500f656ac0c42aa90989">sc::ActiveMsgMemoryGrp</a>, <a class="el" href="classsc_1_1RDMAMemoryGrp.html#aba2bd87b8dcd1342ed606dfef352d09e">sc::RDMAMemoryGrp</a>, and <a class="el" href="classsc_1_1MemoryGrpRegion.html#abfada2eccb31fd56e6d8da9f91923071">sc::MemoryGrpRegion</a>.</p>

</div>
</div>
<a id="a0ef395631d3e3b7fe740e28bb7d9f571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef395631d3e3b7fe740e28bb7d9f571">&#9670;&nbsp;</a></span>sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sc::MemoryGrp::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronizes all the nodes. </p>
<p>This is useful after remote memory writes to be certain that all of the writes have completed and the data can be accessed locally, for example. </p>

<p>Implemented in <a class="el" href="classsc_1_1MTMPIMemoryGrp.html#a113a2c3b575498f47461ada78237ddd8">sc::MTMPIMemoryGrp</a>, <a class="el" href="classsc_1_1MemoryGrpRegion.html#a042c81b274c2286ec02f90e8917b5ddc">sc::MemoryGrpRegion</a>, <a class="el" href="classsc_1_1ARMCIMemoryGrp.html#a56a6e1bd41abd4b944fcf59b58a2f2e8">sc::ARMCIMemoryGrp</a>, <a class="el" href="classsc_1_1ProcMemoryGrp.html#a389e3d5108254f46fab8d3e44066119c">sc::ProcMemoryGrp</a>, and <a class="el" href="classsc_1_1MsgMemoryGrp.html#a0fd841a6c2d1547a8d66134f787f1cdc">sc::MsgMemoryGrp</a>.</p>

</div>
</div>
<a id="a40b4d6586fea20da5df42728225e55c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b4d6586fea20da5df42728225e55c1">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sc::MemoryGrp::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distsize_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to write data directly. </p>
<p>The default implementation uses <a class="el" href="classsc_1_1MemoryGrp.html#afcb8e205f88d6d179b932cbb9a2f3138" title="This gives write access to the memory location. No locking is done.">obtain_writeonly()</a>. More efficient implementations will avoid copies </p>

<p>Reimplemented in <a class="el" href="classsc_1_1ActiveMsgMemoryGrp.html#ade4c711a6d89caf9b4c129a798497f47">sc::ActiveMsgMemoryGrp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/lib/util/group/<a class="el" href="memory_8h_source.html">memory.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr>
<address>
<small>
Generated at Sun Jan 26 2020 23:24:07 for <a
href="http://www.mpqc.org">MPQC</a>
3.0.0-alpha using the documentation package <a
href="http://www.doxygen.org">Doxygen</a>
1.8.16.
</small>
</address>
</body>
</html>
