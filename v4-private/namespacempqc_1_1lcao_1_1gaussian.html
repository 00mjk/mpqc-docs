<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.20"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>MPQC: mpqc::lcao::gaussian Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">MPQC 4.0.0-beta.1</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="intro.html"><span>Introduction</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li class="current"><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempqc.html">mpqc</a></li><li class="navelem"><a class="el" href="namespacempqc_1_1lcao.html">lcao</a></li><li class="navelem"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html">gaussian</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mpqc::lcao::gaussian Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacempqc_1_1lcao_1_1gaussian_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacempqc_1_1lcao_1_1gaussian_1_1precomputed"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1precomputed.html">precomputed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacempqc_1_1lcao_1_1gaussian_1_1utility"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html">utility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian AO integral factory using ab initio Hamiltonian.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_atomic_basis.html">AtomicBasis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_data.html">BasisData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_pair_data.html">BasisPairData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_d_f_task_gemm.html">DFTaskGemm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_d_f_integral_builder.html">DirectDFIntegralBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_data.html">FMMShellData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds shell-specific data relevant to FMM and related methods.  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_pair_data.html">FMMShellPairData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds shell-pair-specific data relevant to FMM and related methods.  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_pair_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">GaussianFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html">IntegralBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds integrals from an array of bases and an integral engine pool.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which holds shell set information for screening.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html">QQRScreen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements QQR screener for shell-sets of integrals.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for Schwarz based screening.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_shell_data.html">ShellData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">aggregate of the Libint2 and SQVl shell data  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_shell_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_shell_pair_data.html">ShellPairData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">aggregate of the Libint2 and SQVl shell-pair data  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_shell_pair_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html">SQVlScreen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html" title="Implements SQVlScreen screener for shell-sets of (0|12) integrals.">SQVlScreen</a> screener for shell-sets of (0|12) integrals.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_data.html">SQVlShellData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds shell-specific data relevant to the SVQ(l) integral estimator described in DOI 10.1063/1.4917519.  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_pair_data.html">SQVlShellPairData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds shell-specific data relevant to the SVQ(l) integral estimator described in DOI 10.1063/1.4917519.  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_pair_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aded59e8a710ae55d49de715671f144c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">Shell</a> = libint2::Shell</td></tr>
<tr class="separator:aded59e8a710ae55d49de715671f144c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867b676d97f85013d7c64e693923168"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> = std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">Shell</a> &gt;</td></tr>
<tr class="separator:ae867b676d97f85013d7c64e693923168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11dd70d8ce057bdd13410952c50f8a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#af11dd70d8ce057bdd13410952c50f8a7">OrbitalBasisRegistry</a> = <a class="el" href="classmpqc_1_1lcao_1_1_orbital_registry.html">OrbitalRegistry</a>&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; &gt;</td></tr>
<tr class="separator:af11dd70d8ce057bdd13410952c50f8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d35833b5878eb21628c0e01ffe4e258"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a> = std::function&lt; const libint2::ShellPair &amp;(std::size_t, std::size_t)&gt;</td></tr>
<tr class="separator:a5d35833b5878eb21628c0e01ffe4e258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6221a3b83530af202804bd12b8ee23c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ac6221a3b83530af202804bd12b8ee23c">q_vector</a> = std::vector&lt; std::pair&lt; double, std::array&lt; double, 3 &gt; &gt;&gt;</td></tr>
<tr class="separator:ac6221a3b83530af202804bd12b8ee23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73c76898429468a8a0d96b64d47c883"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#ae73c76898429468a8a0d96b64d47c883">Shell</a> = <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html#a12190b7d3d8f90effd29483c67b3cdf6">Basis::Shell</a></td></tr>
<tr class="separator:ae73c76898429468a8a0d96b64d47c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566ec309c8eeefe1f5bc2e120ae85f20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a566ec309c8eeefe1f5bc2e120ae85f20">ShellVec</a> = std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">Shell</a> &gt;</td></tr>
<tr class="separator:a566ec309c8eeefe1f5bc2e120ae85f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabe21bf203cac1b6a1c55dd5093e288"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:aaabe21bf203cac1b6a1c55dd5093e288"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a> = std::shared_ptr&lt; <a class="el" href="classmpqc_1_1utility_1_1_t_s_pool.html">mpqc::utility::TSPool</a>&lt; E &gt; &gt;</td></tr>
<tr class="separator:aaabe21bf203cac1b6a1c55dd5093e288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0093954514a5fe80500fe52e3627a7"><td class="memTemplParams" colspan="2">template&lt;unsigned long N&gt; </td></tr>
<tr class="memitem:a4f0093954514a5fe80500fe52e3627a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a4f0093954514a5fe80500fe52e3627a7">BasisRefArray</a> = std::array&lt; std::reference_wrapper&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;, N &gt;</td></tr>
<tr class="separator:a4f0093954514a5fe80500fe52e3627a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dee262f551ab481b1d19fa1744c2b7"><td class="memTemplParams" colspan="2">template&lt;unsigned long N&gt; </td></tr>
<tr class="memitem:a69dee262f551ab481b1d19fa1744c2b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a69dee262f551ab481b1d19fa1744c2b7">BasisShrArray</a> = std::array&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;, N &gt;</td></tr>
<tr class="separator:a69dee262f551ab481b1d19fa1744c2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e1df2244ae775566f28b9e358b5b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a9e4e1df2244ae775566f28b9e358b5b9">BasisRefVector</a> = std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; &gt;</td></tr>
<tr class="separator:a9e4e1df2244ae775566f28b9e358b5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc1d22947aef467a30a88973291a9fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> = std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; &gt;</td></tr>
<tr class="separator:a2bc1d22947aef467a30a88973291a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f200f35a2419ebf17bec11186d1f797"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f200f35a2419ebf17bec11186d1f797"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a7f200f35a2419ebf17bec11186d1f797">OrdTileVec</a> = std::vector&lt; std::pair&lt; unsigned long, T &gt; &gt;</td></tr>
<tr class="separator:a7f200f35a2419ebf17bec11186d1f797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfbe0eb9b925b3f25b546fe6442c32e"><td class="memTemplParams" colspan="2">template&lt;unsigned long N&gt; </td></tr>
<tr class="memitem:aebfbe0eb9b925b3f25b546fe6442c32e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aebfbe0eb9b925b3f25b546fe6442c32e">ShellVecPtrArray</a> = std::array&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const *, N &gt;</td></tr>
<tr class="separator:aebfbe0eb9b925b3f25b546fe6442c32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4d9799486007f292ac8c597553dce604"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a4d9799486007f292ac8c597553dce604">max_am</a> (<a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;)</td></tr>
<tr class="memdesc:a4d9799486007f292ac8c597553dce604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum angular momement of any shell in the vector.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a4d9799486007f292ac8c597553dce604">More...</a><br /></td></tr>
<tr class="separator:a4d9799486007f292ac8c597553dce604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae463540711e7a5718ff6f313ac0d84fb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae463540711e7a5718ff6f313ac0d84fb">max_nprim</a> (<a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;)</td></tr>
<tr class="memdesc:ae463540711e7a5718ff6f313ac0d84fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of primatives of any shell in the vector.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#ae463540711e7a5718ff6f313ac0d84fb">More...</a><br /></td></tr>
<tr class="separator:ae463540711e7a5718ff6f313ac0d84fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc401f93b3cf3989932e8749bd51eee"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a0cc401f93b3cf3989932e8749bd51eee">nfunctions</a> (<a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;)</td></tr>
<tr class="memdesc:a0cc401f93b3cf3989932e8749bd51eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of primatives of any shell in the vector.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a0cc401f93b3cf3989932e8749bd51eee">More...</a><br /></td></tr>
<tr class="separator:a0cc401f93b3cf3989932e8749bd51eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a595ca90ad7766876c70a6111bb177"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; libint2::Shell &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a72a595ca90ad7766876c70a6111bb177">reblock_basis</a> (std::vector&lt; libint2::Shell &gt; shells, std::size_t blocksize)</td></tr>
<tr class="separator:a72a595ca90ad7766876c70a6111bb177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7276834a9db5106be28e8cef8c5def24"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a7276834a9db5106be28e8cef8c5def24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt; Tile, Policy &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a7276834a9db5106be28e8cef8c5def24">to_ao_factory</a> (<a class="el" href="classmpqc_1_1lcao_1_1_a_o_factory.html">lcao::AOFactory</a>&lt; Tile, Policy &gt; &amp;factory)</td></tr>
<tr class="separator:a7276834a9db5106be28e8cef8c5def24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9335060b9b807834dd34448f4e8f2ab9"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a9335060b9b807834dd34448f4e8f2ab9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt; Tile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9335060b9b807834dd34448f4e8f2ab9">to_ao_factory</a> (const std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_a_o_factory.html">lcao::AOFactory</a>&lt; Tile, Policy &gt;&gt; &amp;factory)</td></tr>
<tr class="separator:a9335060b9b807834dd34448f4e8f2ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c1488fee63b080b3a2a33923b5a0da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a40c1488fee63b080b3a2a33923b5a0da">MPQC_EXTERN_TEMPLATE</a> (class <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt;&gt;)</td></tr>
<tr class="separator:a40c1488fee63b080b3a2a33923b5a0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92beac907f517f3e088b5d1064a132cf"><td class="memTemplParams" colspan="2">template&lt;typename OrbSpace &gt; </td></tr>
<tr class="memitem:a92beac907f517f3e088b5d1064a132cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a92beac907f517f3e088b5d1064a132cf">to_molden</a> (std::string_view fname_prefix, const OrbSpace &amp;orbspace, const <a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;wfn_world)</td></tr>
<tr class="memdesc:a92beac907f517f3e088b5d1064a132cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints an orbital space to a Molden file  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a92beac907f517f3e088b5d1064a132cf">More...</a><br /></td></tr>
<tr class="separator:a92beac907f517f3e088b5d1064a132cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade0cff827d164f6eb0aeb54b8129299"><td class="memItemLeft" align="right" valign="top">libint2::Operator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aade0cff827d164f6eb0aeb54b8129299">to_libint2_operator</a> (<a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_oper)</td></tr>
<tr class="separator:aade0cff827d164f6eb0aeb54b8129299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1ff3612c49eae3d422bfb65ce33c5b"><td class="memItemLeft" align="right" valign="top">libint2::any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a7d1ff3612c49eae3d422bfb65ce33c5b">to_libint2_operator_params</a> (<a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_oper, const <a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> &amp;molecule, const std::map&lt; <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>, libint2::any &gt; *oper_params)</td></tr>
<tr class="separator:a7d1ff3612c49eae3d422bfb65ce33c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07479e80d39fec6897ee99c6f59e6667"><td class="memItemLeft" align="right" valign="top">libint2::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a07479e80d39fec6897ee99c6f59e6667">to_libint2_scale_factor</a> (<a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_oper, const std::map&lt; <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>, libint2::any &gt; *oper_params)</td></tr>
<tr class="separator:a07479e80d39fec6897ee99c6f59e6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e680c36e2d80896d7c6471ab953de15"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a6e680c36e2d80896d7c6471ab953de15">index_to_basis</a> (const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#af11dd70d8ce057bdd13410952c50f8a7">OrbitalBasisRegistry</a> &amp;basis_registry, const <a class="el" href="classmpqc_1_1lcao_1_1_orbital_index.html">OrbitalIndex</a> &amp;index)</td></tr>
<tr class="memdesc:a6e680c36e2d80896d7c6471ab953de15"><td class="mdescLeft">&#160;</td><td class="mdescRight">given <a class="el" href="classmpqc_1_1lcao_1_1_orbital_index.html" title="OrbitalIndex denotes a LCAO or AO index space.">OrbitalIndex</a>, find the corresponding basis  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a6e680c36e2d80896d7c6471ab953de15">More...</a><br /></td></tr>
<tr class="separator:a6e680c36e2d80896d7c6471ab953de15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace25fc31194c5c92a23c5faf3a5bdc7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aace25fc31194c5c92a23c5faf3a5bdc7">parallel_compute_shellpair_list</a> (madness::World &amp;world, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis1, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis2, double threshold=1e-12, double engine_precision=0.0)</td></tr>
<tr class="memdesc:aace25fc31194c5c92a23c5faf3a5bdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes non-negligible shell pair list; shells <code>i</code> and <code>j</code> form a non-negligible pair if they share a center or the Frobenius norm of their overlap is greater than threshold.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#aace25fc31194c5c92a23c5faf3a5bdc7">More...</a><br /></td></tr>
<tr class="separator:aace25fc31194c5c92a23c5faf3a5bdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c55803bc67c68c00545f63c95bb3de"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a13c55803bc67c68c00545f63c95bb3de"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a13c55803bc67c68c00545f63c95bb3de">make_screener</a> (madness::World &amp;world, const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; libint2::Engine &gt; &amp;engine, Bases &amp;&amp;bases, const std::string &amp;screen, double screen_threshold)</td></tr>
<tr class="memdesc:a13c55803bc67c68c00545f63c95bb3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory for <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html" title="ThresholdedScreener is a Screener equipped with a (mutable) real threshold.">ThresholdedScreener</a> objects  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a13c55803bc67c68c00545f63c95bb3de">More...</a><br /></td></tr>
<tr class="separator:a13c55803bc67c68c00545f63c95bb3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495f8506c53e58393a1b7fae3b5c04e6"><td class="memTemplParams" colspan="2">template&lt;typename Policy , bool is_real = true&gt; </td></tr>
<tr class="memitem:a495f8506c53e58393a1b7fae3b5c04e6"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; TA::TensorD, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a495f8506c53e58393a1b7fae3b5c04e6">tensorZ_to_tensorD</a> (const TA::DistArray&lt; TA::TensorZ, Policy &gt; &amp;complex_array)</td></tr>
<tr class="memdesc:a495f8506c53e58393a1b7fae3b5c04e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes real or imaginary part from a complex array.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a495f8506c53e58393a1b7fae3b5c04e6">More...</a><br /></td></tr>
<tr class="separator:a495f8506c53e58393a1b7fae3b5c04e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc18a3a5d5d74dbc290e0c270df4a225"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:acc18a3a5d5d74dbc290e0c270df4a225"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#acc18a3a5d5d74dbc290e0c270df4a225">compute_shellblock_norm</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;bs0, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;bs1, const TA::DistArray&lt; Tile, Policy &gt; &amp;D)</td></tr>
<tr class="separator:acc18a3a5d5d74dbc290e0c270df4a225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfb4b1af5b79980a7f8cda03ac1a96e"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a0bfb4b1af5b79980a7f8cda03ac1a96e"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a0bfb4b1af5b79980a7f8cda03ac1a96e">compute_shellblock_norm</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;bs0, const TA::DistArray&lt; Tile, Policy &gt; &amp;D)</td></tr>
<tr class="separator:a0bfb4b1af5b79980a7f8cda03ac1a96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836c38a16ec7df825a56d3ff44ef0abd"><td class="memTemplParams" colspan="2">template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine  = libint2::Engine, typename Bases &gt; </td></tr>
<tr class="memitem:a836c38a16ec7df825a56d3ff44ef0abd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a836c38a16ec7df825a56d3ff44ef0abd">direct_sparse_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;(), std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a836c38a16ec7df825a56d3ff44ef0abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct direct integral tensors in parallel with screening.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a836c38a16ec7df825a56d3ff44ef0abd">More...</a><br /></td></tr>
<tr class="separator:a836c38a16ec7df825a56d3ff44ef0abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ee11f612148f24e99d4d42990456e7"><td class="memTemplParams" colspan="2">template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Idx , typename Bases &gt; </td></tr>
<tr class="memitem:a85ee11f612148f24e99d4d42990456e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a85ee11f612148f24e99d4d42990456e7">direct_sparse_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt; shr_pool, Bases &amp;&amp;bases, std::vector&lt; std::pair&lt; Idx, float &gt;&gt; const &amp;user_provided_norms, bool user_provided_norms_perelem, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;(), std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a85ee11f612148f24e99d4d42990456e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct direct integral tensors in parallel with screening.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a85ee11f612148f24e99d4d42990456e7">More...</a><br /></td></tr>
<tr class="separator:a85ee11f612148f24e99d4d42990456e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ae2a6d9f9b977526a464c541696afe"><td class="memTemplParams" colspan="2">template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Bases &gt; </td></tr>
<tr class="memitem:a01ae2a6d9f9b977526a464c541696afe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy, Engine &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a01ae2a6d9f9b977526a464c541696afe">untruncated_direct_sparse_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;(), std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a01ae2a6d9f9b977526a464c541696afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct direct integral tensors in parallel with screening.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a01ae2a6d9f9b977526a464c541696afe">More...</a><br /></td></tr>
<tr class="separator:a01ae2a6d9f9b977526a464c541696afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9407669ccb41dcf8c29ebf746e723b61"><td class="memTemplParams" colspan="2">template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Bases &gt; </td></tr>
<tr class="memitem:a9407669ccb41dcf8c29ebf746e723b61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::DensePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9407669ccb41dcf8c29ebf746e723b61">direct_dense_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;(), std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a9407669ccb41dcf8c29ebf746e723b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct direct dense integral tensors in parallel with screening.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a9407669ccb41dcf8c29ebf746e723b61">More...</a><br /></td></tr>
<tr class="separator:a9407669ccb41dcf8c29ebf746e723b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19680d60da9f6dc2a29448356f2bbad3"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a19680d60da9f6dc2a29448356f2bbad3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::DensePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a19680d60da9f6dc2a29448356f2bbad3">df_direct_integrals</a> (const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;bra, const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;ket, <a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3">Formula::Notation</a> notation=<a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3af5b28c5994e6d7ab604ddcd503be7fc0">Formula::Notation::Chemical</a>)</td></tr>
<tr class="separator:a19680d60da9f6dc2a29448356f2bbad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9945509dc4ad97605e15e0482950b1"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a2f9945509dc4ad97605e15e0482950b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a2f9945509dc4ad97605e15e0482950b1">df_direct_integrals</a> (const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;bra, const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;ket, <a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3">Formula::Notation</a> notation=<a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3af5b28c5994e6d7ab604ddcd503be7fc0">Formula::Notation::Chemical</a>)</td></tr>
<tr class="separator:a2f9945509dc4ad97605e15e0482950b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cae10c8949c00ce0fb88516703d183f"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ComputeTile  = Tile, typename Engine  = libint2::Engine&gt; </td></tr>
<tr class="memitem:a3cae10c8949c00ce0fb88516703d183f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html">IntegralBuilder</a>&lt; Tile, ComputeTile, Engine &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a3cae10c8949c00ce0fb88516703d183f">make_integral_builder</a> (<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt; shr_epool, const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> &amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; shr_screen, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a3cae10c8949c00ce0fb88516703d183f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make detection of template parameters easier, see <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html" title="Builds integrals from an array of bases and an integral engine pool.">IntegralBuilder</a> for details.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a3cae10c8949c00ce0fb88516703d183f">More...</a><br /></td></tr>
<tr class="separator:a3cae10c8949c00ce0fb88516703d183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86116ea844a66713be56213d7d806372"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ComputeTile  = Tile, typename Engine  = libint2::Engine&gt; </td></tr>
<tr class="memitem:a86116ea844a66713be56213d7d806372"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a>&lt; Tile, ComputeTile, Engine &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a86116ea844a66713be56213d7d806372">make_direct_integral_builder</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt; shr_epool, const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> &amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; shr_screen, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a86116ea844a66713be56213d7d806372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make detection of template parameters easier, see <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a> for details.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a86116ea844a66713be56213d7d806372">More...</a><br /></td></tr>
<tr class="separator:a86116ea844a66713be56213d7d806372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ae928b9493ddc6fe939dfd490f099b"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a85ae928b9493ddc6fe939dfd490f099b"><td class="memTemplItemLeft" align="right" valign="top">libint2::Engine&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a85ae928b9493ddc6fe939dfd490f099b">make_engine</a> (const libint2::Operator &amp;oper, Bases &amp;&amp;bases, libint2::BraKet braket=libint2::BraKet::invalid, libint2::any oper_params=libint2::any(), double engine_precision=std::numeric_limits&lt; double &gt;::epsilon(), const libint2::scalar_type &amp;scalar=libint2::scalar_type(1.0))</td></tr>
<tr class="separator:a85ae928b9493ddc6fe939dfd490f099b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9410ff222048d9db3e3ab7d7ad25e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ac6221a3b83530af202804bd12b8ee23c">q_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a1e9410ff222048d9db3e3ab7d7ad25e0">make_q</a> (<a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;mol)</td></tr>
<tr class="separator:a1e9410ff222048d9db3e3ab7d7ad25e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542db3cc3c33b6a964f4eac519b3f34b"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a542db3cc3c33b6a964f4eac519b3f34b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; libint2::Engine &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a542db3cc3c33b6a964f4eac519b3f34b">make_engine_pool</a> (const libint2::Operator &amp;oper, Bases &amp;&amp;bases, libint2::BraKet braket=libint2::BraKet::invalid, libint2::any oper_params=libint2::any(), const libint2::scalar_type &amp;scalar=libint2::scalar_type(1.0), double engine_precision=std::numeric_limits&lt; double &gt;::epsilon())</td></tr>
<tr class="memdesc:a542db3cc3c33b6a964f4eac519b3f34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an pool of Engine objects.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a542db3cc3c33b6a964f4eac519b3f34b">More...</a><br /></td></tr>
<tr class="separator:a542db3cc3c33b6a964f4eac519b3f34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97351117a9d55ea2cdef8a8dc69b140a"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Bases &gt; </td></tr>
<tr class="memitem:a97351117a9d55ea2cdef8a8dc69b140a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html">QQRScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a97351117a9d55ea2cdef8a8dc69b140a">create_qqr_screener</a> (madness::World &amp;world, const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; &amp;engs, Bases &amp;&amp;bases, double threshold, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>)</td></tr>
<tr class="separator:a97351117a9d55ea2cdef8a8dc69b140a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa037266c1937ea7d9b1d7cb4441245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#affa037266c1937ea7d9b1d7cb4441245">operator==</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &amp;first, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &amp;second)</td></tr>
<tr class="separator:affa037266c1937ea7d9b1d7cb4441245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e605257eede9d104faebc3d674ad97"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Bases &gt; </td></tr>
<tr class="memitem:a67e605257eede9d104faebc3d674ad97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a67e605257eede9d104faebc3d674ad97">create_schwarz_screener</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; const &amp;eng, Bases &amp;&amp;bs_array, double thresh, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>)</td></tr>
<tr class="memdesc:a67e605257eede9d104faebc3d674ad97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Schwarz <a class="el" href="classmpqc_1_1lcao_1_1_screener.html" title="Base class for screeners will never skip any integrals.">Screener</a>.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a67e605257eede9d104faebc3d674ad97">More...</a><br /></td></tr>
<tr class="separator:a67e605257eede9d104faebc3d674ad97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7b9d0650bd801180e3f92104807b43"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Bases &gt; </td></tr>
<tr class="memitem:adc7b9d0650bd801180e3f92104807b43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html">SQVlScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#adc7b9d0650bd801180e3f92104807b43">create_sqvl_screener</a> (madness::World &amp;world, const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; &amp;engs, Bases &amp;&amp;bases, double threshold, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>)</td></tr>
<tr class="separator:adc7b9d0650bd801180e3f92104807b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6700bc880ddaf60393065243c2ce368c"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </td></tr>
<tr class="memitem:a6700bc880ddaf60393065243c2ce368c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a6700bc880ddaf60393065243c2ce368c">sparse_xyz_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="memdesc:a6700bc880ddaf60393065243c2ce368c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct set of sparse integral tensors in parallel.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a6700bc880ddaf60393065243c2ce368c">More...</a><br /></td></tr>
<tr class="separator:a6700bc880ddaf60393065243c2ce368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562c40588c14c527e3ff40e11fe887a7"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Bases , typename Tile  = TA::TensorD&gt; </td></tr>
<tr class="memitem:a562c40588c14c527e3ff40e11fe887a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, TA::DensePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a562c40588c14c527e3ff40e11fe887a7">dense_xyz_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="memdesc:a562c40588c14c527e3ff40e11fe887a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct dense integral tensors from sets in parallel.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a562c40588c14c527e3ff40e11fe887a7">More...</a><br /></td></tr>
<tr class="separator:a562c40588c14c527e3ff40e11fe887a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c671ec0c925b5d39c9415968df9fb0"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </td></tr>
<tr class="memitem:a74c671ec0c925b5d39c9415968df9fb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;::value, TA::DensePolicy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a74c671ec0c925b5d39c9415968df9fb0">xyz_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:a74c671ec0c925b5d39c9415968df9fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b86eb8ac6c5d51a043d1365c426f3a4"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </td></tr>
<tr class="memitem:a1b86eb8ac6c5d51a043d1365c426f3a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;::value, TA::SparsePolicy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a1b86eb8ac6c5d51a043d1365c426f3a4">xyz_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:a1b86eb8ac6c5d51a043d1365c426f3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2de94f551f0988a2180f5e3526f7c7"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </td></tr>
<tr class="memitem:a0a2de94f551f0988a2180f5e3526f7c7"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a0a2de94f551f0988a2180f5e3526f7c7">sparse_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{}, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a0a2de94f551f0988a2180f5e3526f7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct sparse integral tensors in parallel.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a0a2de94f551f0988a2180f5e3526f7c7">More...</a><br /></td></tr>
<tr class="separator:a0a2de94f551f0988a2180f5e3526f7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aa0d517902ef18d70779465680075b"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </td></tr>
<tr class="memitem:a13aa0d517902ef18d70779465680075b"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, TA::DensePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a13aa0d517902ef18d70779465680075b">dense_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{}, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a13aa0d517902ef18d70779465680075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dense integral tensor in parallel.  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a13aa0d517902ef18d70779465680075b">More...</a><br /></td></tr>
<tr class="separator:a13aa0d517902ef18d70779465680075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084a49b2b9eeca3cd7cdafe88844110e"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Bases &gt; </td></tr>
<tr class="memitem:a084a49b2b9eeca3cd7cdafe88844110e"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;::value, TA::SparsePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a084a49b2b9eeca3cd7cdafe88844110e">compute_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; libint2::Engine &gt; &amp;engine, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; p_screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:a084a49b2b9eeca3cd7cdafe88844110e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e2f17f8d1b9493fde89dc66a7dfd12"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Bases &gt; </td></tr>
<tr class="memitem:a18e2f17f8d1b9493fde89dc66a7dfd12"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;::value, TA::DensePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a18e2f17f8d1b9493fde89dc66a7dfd12">compute_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; libint2::Engine &gt; &amp;engine, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; p_screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:a18e2f17f8d1b9493fde89dc66a7dfd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbd7917960a8685a05156509a261fca"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a6bbd7917960a8685a05156509a261fca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a6bbd7917960a8685a05156509a261fca">to_basis_shr_vector</a> (Bases &amp;&amp;bases)</td></tr>
<tr class="separator:a6bbd7917960a8685a05156509a261fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492cb6acdacebec0bdd36ea4cfcef333"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a492cb6acdacebec0bdd36ea4cfcef333"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a9e4e1df2244ae775566f28b9e358b5b9">BasisRefVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a492cb6acdacebec0bdd36ea4cfcef333">to_basis_ref_vector</a> (Bases &amp;&amp;bases)</td></tr>
<tr class="separator:a492cb6acdacebec0bdd36ea4cfcef333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb82203b8daaa8bc9d9dda48d806606"><td class="memTemplParams" colspan="2">template&lt;typename BS &gt; </td></tr>
<tr class="memitem:acdb82203b8daaa8bc9d9dda48d806606"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#acdb82203b8daaa8bc9d9dda48d806606">to_basis_ref</a> (BS &amp;&amp;bs)</td></tr>
<tr class="separator:acdb82203b8daaa8bc9d9dda48d806606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4b4abad3a50bf2c3986c8ba27ae671"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a3b4b4abad3a50bf2c3986c8ba27ae671"><td class="memTemplItemLeft" align="right" valign="top">TA::TiledRange&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a3b4b4abad3a50bf2c3986c8ba27ae671">make_trange</a> (Bases &amp;&amp;bases)</td></tr>
<tr class="separator:a3b4b4abad3a50bf2c3986c8ba27ae671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942f208ee79fac7bc7949f92d433eebb"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Array &gt; </td></tr>
<tr class="memitem:a942f208ee79fac7bc7949f92d433eebb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a942f208ee79fac7bc7949f92d433eebb">set_array</a> (std::vector&lt; std::pair&lt; unsigned long, Tile &gt;&gt; &amp;tiles, <a class="el" href="namespacempqc.html#a993bcbe3ace34fa22d75c413480ab899">Array</a> &amp;a)</td></tr>
<tr class="separator:a942f208ee79fac7bc7949f92d433eebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09985a943c3a22f248f1c055ceb845f"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:af09985a943c3a22f248f1c055ceb845f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#af09985a943c3a22f248f1c055ceb845f">set_array</a> (std::vector&lt; std::pair&lt; unsigned long, Tile &gt;&gt; &amp;tiles, <a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TiledArray::DistArrayVector</a>&lt; Tile, Policy &gt; &amp;a)</td></tr>
<tr class="separator:af09985a943c3a22f248f1c055ceb845f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24f4ec89de556dfce536b5a9088cd60"><td class="memTemplParams" colspan="2">template&lt;typename Engs , typename Tile , typename ComputeTile , typename Policy &gt; </td></tr>
<tr class="memitem:ae24f4ec89de556dfce536b5a9088cd60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae24f4ec89de556dfce536b5a9088cd60">soad_task</a> (Engs eng_pool, const std::array&lt; int64_t, 2 &gt; &amp;tile_idx, const std::array&lt; std::vector&lt; libint2::Shell &gt; const *, 2 &gt; &amp;obs_row_and_col_ptrs, std::vector&lt; libint2::Shell &gt; const *min_bs, const <a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a> *D, TA::DistArray&lt; Tile, Policy &gt; *F, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op, const std::array&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>, 3 &gt; *shellpair_data_accessors, const std::array&lt; std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a> &gt;, 2 &gt; *jk_screeners)</td></tr>
<tr class="separator:ae24f4ec89de556dfce536b5a9088cd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9aaf985defe6b569667d6c12f129fd"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </td></tr>
<tr class="memitem:acb9aaf985defe6b569667d6c12f129fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;::value, TA::SparsePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#acb9aaf985defe6b569667d6c12f129fd">fock_from_soad</a> (madness::World &amp;world, <a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;clustered_mol, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;obs, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;minbs, TA::DistArray&lt; Tile, Policy &gt; const &amp;H, int const n_components, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *bs0, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *bs1)&gt; make_shellpair_data_accessor={}, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;())</td></tr>
<tr class="separator:acb9aaf985defe6b569667d6c12f129fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9278c8a3287aeb57d4505297eb4b5407"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </td></tr>
<tr class="memitem:a9278c8a3287aeb57d4505297eb4b5407"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;::value, TA::DensePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9278c8a3287aeb57d4505297eb4b5407">fock_from_soad</a> (madness::World &amp;world, <a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;clustered_mol, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;obs, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;minbs, TA::DistArray&lt; Tile, Policy &gt; const &amp;H, int const n_components, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *bs0, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *bs1)&gt; make_shellpair_data_accessor={}, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;())</td></tr>
<tr class="separator:a9278c8a3287aeb57d4505297eb4b5407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5bd9c684fc72526ba39a59078b49c1ac"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5bd9c684fc72526ba39a59078b49c1ac">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html">Basis::Factory</a> const &amp;f)</td></tr>
<tr class="separator:a5bd9c684fc72526ba39a59078b49c1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e9e89bdcfc1878433bdaf57f037006"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ab8e9e89bdcfc1878433bdaf57f037006">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;b)</td></tr>
<tr class="separator:ab8e9e89bdcfc1878433bdaf57f037006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d324854ba6f208cda3f9bdce132d412"><td class="memItemLeft" align="right" valign="top">Eigen::RowVectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a3d324854ba6f208cda3f9bdce132d412">sub_basis_map</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;sub_basis)</td></tr>
<tr class="separator:a3d324854ba6f208cda3f9bdce132d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735c5727f3f7be9f0886042c24498b7e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a735c5727f3f7be9f0886042c24498b7e">merge</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis1, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis2)</td></tr>
<tr class="separator:a735c5727f3f7be9f0886042c24498b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d921175ffc2f59e28f7322f23c1441e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a0d921175ffc2f59e28f7322f23c1441e">parallel_make_basis</a> (madness::World &amp;world, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html">Basis::Factory</a> &amp;factory, const <a class="el" href="classmpqc_1_1_molecule.html">mpqc::Molecule</a> &amp;mol)</td></tr>
<tr class="separator:a0d921175ffc2f59e28f7322f23c1441e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14daf97f21a6466f9985c84b21333b6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ac14daf97f21a6466f9985c84b21333b6">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_atomic_basis.html">AtomicBasis</a> const &amp;b)</td></tr>
<tr class="separator:ac14daf97f21a6466f9985c84b21333b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755d72248fbad1639c6a94f42bf123a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a755d72248fbad1639c6a94f42bf123a1">operator==</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;one, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;two)</td></tr>
<tr class="separator:a755d72248fbad1639c6a94f42bf123a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1c7f2871adeb31e61bbb5b402097b1"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename... Args&gt; </td></tr>
<tr class="memitem:a7b1c7f2871adeb31e61bbb5b402097b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a7b1c7f2871adeb31e61bbb5b402097b1">reblock</a> (<a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;basis, Op op, Args... args)</td></tr>
<tr class="memdesc:a7b1c7f2871adeb31e61bbb5b402097b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">reblock allows for reblocking a basis  <a href="namespacempqc_1_1lcao_1_1gaussian.html#a7b1c7f2871adeb31e61bbb5b402097b1">More...</a><br /></td></tr>
<tr class="separator:a7b1c7f2871adeb31e61bbb5b402097b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af11dd70d8ce057bdd13410952c50f8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11dd70d8ce057bdd13410952c50f8a7">&#9670;&nbsp;</a></span>OrbitalBasisRegistry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmpqc_1_1lcao_1_1_orbital_registry.html">lcao::OrbitalRegistry</a>&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; &gt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#af11dd70d8ce057bdd13410952c50f8a7">mpqc::lcao::gaussian::OrbitalBasisRegistry</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef of OrbitalBasisRegistry A <a class="el" href="classmpqc_1_1_registry.html" title="a wrapper of std::map, not thread_safe for writing">Registry</a> that maps <a class="el" href="classmpqc_1_1lcao_1_1_orbital_index.html" title="OrbitalIndex denotes a LCAO or AO index space.">OrbitalIndex</a> to a Gaussian <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> </p>

</div>
</div>
<a id="ac6221a3b83530af202804bd12b8ee23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6221a3b83530af202804bd12b8ee23c">&#9670;&nbsp;</a></span>q_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ac6221a3b83530af202804bd12b8ee23c">mpqc::lcao::gaussian::q_vector</a> = typedef std::vector&lt;std::pair&lt;double, std::array&lt;double, 3&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aded59e8a710ae55d49de715671f144c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded59e8a710ae55d49de715671f144c4">&#9670;&nbsp;</a></span>Shell <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef libint2::Shell <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">mpqc::lcao::gaussian::Shell</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d35833b5878eb21628c0e01ffe4e258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d35833b5878eb21628c0e01ffe4e258">&#9670;&nbsp;</a></span>shellpair_data_accessor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">mpqc::lcao::gaussian::shellpair_data_accessor_t</a> = typedef std::function&lt;const libint2::ShellPair &amp;(std::size_t, std::size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae867b676d97f85013d7c64e693923168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae867b676d97f85013d7c64e693923168">&#9670;&nbsp;</a></span>ShellVec <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">Shell</a> &gt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">mpqc::lcao::gaussian::ShellVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a084a49b2b9eeca3cd7cdafe88844110e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084a49b2b9eeca3cd7cdafe88844110e">&#9670;&nbsp;</a></span>compute_integrals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, typename std::enable_if&lt;std::is_same&lt;Policy, TA::SparsePolicy&gt;::value, TA::SparsePolicy&gt;::type&gt; mpqc::lcao::gaussian::compute_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; libint2::Engine &gt; &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>p_screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18e2f17f8d1b9493fde89dc66a7dfd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e2f17f8d1b9493fde89dc66a7dfd12">&#9670;&nbsp;</a></span>compute_integrals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, typename std::enable_if&lt;std::is_same&lt;Policy, TA::DensePolicy&gt;::value, TA::DensePolicy&gt;::type&gt; mpqc::lcao::gaussian::compute_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; libint2::Engine &gt; &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>p_screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc18a3a5d5d74dbc290e0c270df4a225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc18a3a5d5d74dbc290e0c270df4a225">&#9670;&nbsp;</a></span>compute_shellblock_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt;Tile, Policy&gt; mpqc::lcao::gaussian::compute_shellblock_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>bs0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>bs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bfb4b1af5b79980a7f8cda03ac1a96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfb4b1af5b79980a7f8cda03ac1a96e">&#9670;&nbsp;</a></span>compute_shellblock_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt;Tile, Policy&gt; mpqc::lcao::gaussian::compute_shellblock_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>bs0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97351117a9d55ea2cdef8a8dc69b140a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97351117a9d55ea2cdef8a8dc69b140a">&#9670;&nbsp;</a></span>create_qqr_screener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html">QQRScreen</a> mpqc::lcao::gaussian::create_qqr_screener </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>engs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67e605257eede9d104faebc3d674ad97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e605257eede9d104faebc3d674ad97">&#9670;&nbsp;</a></span>create_schwarz_screener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a> mpqc::lcao::gaussian::create_schwarz_screener </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>eng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bs_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Schwarz <a class="el" href="classmpqc_1_1lcao_1_1_screener.html" title="Base class for screeners will never skip any integrals.">Screener</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>an engine type </td></tr>
    <tr><td class="paramname">Bases</td><td>a directly-addressable sequence of basis sets (or reference proxies, e.g. std::reference_wrapper)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>is a reference to the world in which the distributed screener data will be computed and stores</td></tr>
    <tr><td class="paramname">eng</td><td>is a reference to a ShrPool&lt;E&gt;</td></tr>
    <tr><td class="paramname">bs_array</td><td>is a reference to a directly-addressable sequence of basis sets, if the length is 3 then DF integrals are assumed and the first basis is assumed to be the auxiliary basis if the length is 4 then it is assumed that four center screening is desired. There is no requirement that any basis sets be the same.</td></tr>
    <tr><td class="paramname">thresh</td><td>is the Schwarz Screening threshold</td></tr>
    <tr><td class="paramname">norm_func</td><td>is the function pointer that returns a norm, it should have a signature double (Eigen::Map&lt;const RowMatrixXd&gt; const &amp;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc7b9d0650bd801180e3f92104807b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7b9d0650bd801180e3f92104807b43">&#9670;&nbsp;</a></span>create_sqvl_screener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html">SQVlScreen</a> mpqc::lcao::gaussian::create_sqvl_screener </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>engs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13aa0d517902ef18d70779465680075b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13aa0d517902ef18d70779465680075b">&#9670;&nbsp;</a></span>dense_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt;Tile, TA::DensePolicy&gt; mpqc::lcao::gaussian::dense_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a dense integral tensor in parallel. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a0a2de94f551f0988a2180f5e3526f7c7" title="Construct sparse integral tensors in parallel.">sparse_integrals</a> </dd></dl>

</div>
</div>
<a id="a562c40588c14c527e3ff40e11fe887a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562c40588c14c527e3ff40e11fe887a7">&#9670;&nbsp;</a></span>dense_xyz_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Bases , typename Tile  = TA::TensorD&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt;Tile, TA::DensePolicy&gt; mpqc::lcao::gaussian::dense_xyz_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct dense integral tensors from sets in parallel. </p>
<p>This is needed for integrals such as the dipole integrals that come as a set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shr_pool</td><td>should be a std::shared_ptr to an IntegralEnginePool </td></tr>
    <tr><td class="paramname">bases</td><td>should be a std::array of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>, which will be copied. </td></tr>
    <tr><td class="paramname">op</td><td>needs to be a function or functor that takes a TA::TensorD &amp;&amp; and returns any valid tile type. Op is copied so it can be moved. <div class="fragment"><div class="line"><span class="keyword">auto</span> t = [](TA::TensorD &amp;&amp;ten){<span class="keywordflow">return</span> std::move(ten);};</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19680d60da9f6dc2a29448356f2bbad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19680d60da9f6dc2a29448356f2bbad3">&#9670;&nbsp;</a></span>df_direct_integrals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt;Tile, TA::DensePolicy&gt; mpqc::lcao::gaussian::df_direct_integrals </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3">Formula::Notation</a>&#160;</td>
          <td class="paramname"><em>notation</em> = <code><a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3af5b28c5994e6d7ab604ddcd503be7fc0">Formula::Notation::Chemical</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct direct dense LCAO integral from density fitting </p>

</div>
</div>
<a id="a2f9945509dc4ad97605e15e0482950b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9945509dc4ad97605e15e0482950b1">&#9670;&nbsp;</a></span>df_direct_integrals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt;Tile, TA::SparsePolicy&gt; mpqc::lcao::gaussian::df_direct_integrals </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3">Formula::Notation</a>&#160;</td>
          <td class="paramname"><em>notation</em> = <code><a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3af5b28c5994e6d7ab604ddcd503be7fc0">Formula::Notation::Chemical</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct direct sparse LCAO integral from density fitting </p>

</div>
</div>
<a id="a9407669ccb41dcf8c29ebf746e723b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9407669ccb41dcf8c29ebf746e723b61">&#9670;&nbsp;</a></span>direct_dense_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt;Tile, TA::DensePolicy&gt; mpqc::lcao::gaussian::direct_dense_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct direct dense integral tensors in parallel with screening. </p>
<p>Same requirements on Op as those in Integral Builder </p>

</div>
</div>
<a id="a836c38a16ec7df825a56d3ff44ef0abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836c38a16ec7df825a56d3ff44ef0abd">&#9670;&nbsp;</a></span>direct_sparse_integrals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine  = libint2::Engine, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt;Tile, TA::SparsePolicy&gt; mpqc::lcao::gaussian::direct_sparse_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct direct integral tensors in parallel with screening. </p>
<p>Same requirements on Op as those in Integral Builder </p>

</div>
</div>
<a id="a85ee11f612148f24e99d4d42990456e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ee11f612148f24e99d4d42990456e7">&#9670;&nbsp;</a></span>direct_sparse_integrals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Idx , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt;Tile, TA::SparsePolicy&gt; mpqc::lcao::gaussian::direct_sparse_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; Idx, float &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>user_provided_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user_provided_norms_perelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct direct integral tensors in parallel with screening. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_provided_norms</td><td>is a user supplied replicated tensor with the norm estimates for the array. It is of type vector&lt;std::pair&lt;Idx, float&gt;&gt; where Idx is a type that provides random access via operator[] and the values are the indices of the tile. The float is then the norm estimate for that tile. </td></tr>
    <tr><td class="paramname">user_provided_norms_perelem</td><td>whether user_provided_norms are already scaled (per-element) or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb9aaf985defe6b569667d6c12f129fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9aaf985defe6b569667d6c12f129fd">&#9670;&nbsp;</a></span>fock_from_soad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, typename std::enable_if&lt;std::is_same&lt;Policy, TA::SparsePolicy&gt;::value, TA::SparsePolicy&gt;::type&gt; mpqc::lcao::gaussian::fock_from_soad </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;&#160;</td>
          <td class="paramname"><em>clustered_mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>minbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::DistArray&lt; Tile, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>n_components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *bs0, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *bs1)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fock matrix computed from soad for SparsePolicy </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tile</td><td>a Tile type for the result </td></tr>
    <tr><td class="paramname">ComputeTile</td><td>the storage tile for integrals </td></tr>
    <tr><td class="paramname">Policy</td><td>TA::SparsePolicy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>world object </td></tr>
    <tr><td class="paramname">clustered_mol</td><td>molecule class </td></tr>
    <tr><td class="paramname">obs</td><td>basis object </td></tr>
    <tr><td class="paramname">minbs</td><td>minimal basis object </td></tr>
    <tr><td class="paramname">engs</td><td>engine </td></tr>
    <tr><td class="paramname">H</td><td>H matrix </td></tr>
    <tr><td class="paramname">n_components</td><td>number of components (size) of returned DistArrayVector </td></tr>
    <tr><td class="paramname">op</td><td>operator to convert ComputeTile to Tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Fock matrix from soad </dd></dl>

</div>
</div>
<a id="a9278c8a3287aeb57d4505297eb4b5407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9278c8a3287aeb57d4505297eb4b5407">&#9670;&nbsp;</a></span>fock_from_soad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, typename std::enable_if&lt;std::is_same&lt;Policy, TA::DensePolicy&gt;::value, TA::DensePolicy&gt;::type&gt; mpqc::lcao::gaussian::fock_from_soad </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;&#160;</td>
          <td class="paramname"><em>clustered_mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>minbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::DistArray&lt; Tile, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>n_components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *bs0, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *bs1)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fock matrix computed from soad for DensePolicy </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ShrPool</td><td></td></tr>
    <tr><td class="paramname">Tile</td><td>a Tile type for the result </td></tr>
    <tr><td class="paramname">ComputeTile</td><td>the storage tile for integrals </td></tr>
    <tr><td class="paramname">Policy</td><td>TA::DensePolicy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>world object </td></tr>
    <tr><td class="paramname">clustered_mol</td><td>molecule class </td></tr>
    <tr><td class="paramname">obs</td><td>basis object </td></tr>
    <tr><td class="paramname">minbs</td><td>minimal basis object </td></tr>
    <tr><td class="paramname">engs</td><td>engine </td></tr>
    <tr><td class="paramname">H</td><td>H matrix </td></tr>
    <tr><td class="paramname">n_components</td><td>number of components (size) of returned DistArrayVector </td></tr>
    <tr><td class="paramname">op</td><td>operator to convert ComputeTile to Tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Fock matrix from soad </dd></dl>

</div>
</div>
<a id="a6e680c36e2d80896d7c6471ab953de15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e680c36e2d80896d7c6471ab953de15">&#9670;&nbsp;</a></span>index_to_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; mpqc::lcao::gaussian::index_to_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#af11dd70d8ce057bdd13410952c50f8a7">OrbitalBasisRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>basis_registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1_orbital_index.html">OrbitalIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given <a class="el" href="classmpqc_1_1lcao_1_1_orbital_index.html" title="OrbitalIndex denotes a LCAO or AO index space.">OrbitalIndex</a>, find the corresponding basis </p>

</div>
</div>
<a id="a86116ea844a66713be56213d7d806372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86116ea844a66713be56213d7d806372">&#9670;&nbsp;</a></span>make_direct_integral_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ComputeTile  = Tile, typename Engine  = libint2::Engine&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a>&lt;Tile, ComputeTile, Engine&gt; &gt; mpqc::lcao::gaussian::make_direct_integral_builder </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_epool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>shr_screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to make detection of template parameters easier, see <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a> for details. </p>

</div>
</div>
<a id="a85ae928b9493ddc6fe939dfd490f099b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ae928b9493ddc6fe939dfd490f099b">&#9670;&nbsp;</a></span>make_engine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libint2::Engine mpqc::lcao::gaussian::make_engine </td>
          <td>(</td>
          <td class="paramtype">const libint2::Operator &amp;&#160;</td>
          <td class="paramname"><em>oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libint2::BraKet&#160;</td>
          <td class="paramname"><em>braket</em> = <code>libint2::BraKet::invalid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libint2::any&#160;</td>
          <td class="paramname"><em>oper_params</em> = <code>libint2::any()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>engine_precision</em> = <code>std::numeric_limits&lt;double&gt;::epsilon()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libint2::scalar_type &amp;&#160;</td>
          <td class="paramname"><em>scalar</em> = <code>libint2::scalar_type(1.0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>makes an engine for computing integrals of operator <code>oper</code> over bases <code>bases</code> </p>

</div>
</div>
<a id="a542db3cc3c33b6a964f4eac519b3f34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542db3cc3c33b6a964f4eac519b3f34b">&#9670;&nbsp;</a></span>make_engine_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt;libint2::Engine&gt; mpqc::lcao::gaussian::make_engine_pool </td>
          <td>(</td>
          <td class="paramtype">const libint2::Operator &amp;&#160;</td>
          <td class="paramname"><em>oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libint2::BraKet&#160;</td>
          <td class="paramname"><em>braket</em> = <code>libint2::BraKet::invalid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libint2::any&#160;</td>
          <td class="paramname"><em>oper_params</em> = <code>libint2::any()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libint2::scalar_type &amp;&#160;</td>
          <td class="paramname"><em>scalar</em> = <code>libint2::scalar_type(1.0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>engine_precision</em> = <code>std::numeric_limits&lt;double&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an pool of Engine objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Bases</td><td>a contiguous range of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> objects or std::reference_wrapper's to (const) <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oper</td><td>the operator type </td></tr>
    <tr><td class="paramname">bases</td><td>an object of Bases type </td></tr>
    <tr><td class="paramname">braket</td><td>the braket type; the default is to use the value returned by <code>libint2::default_braket(oper)</code> </td></tr>
    <tr><td class="paramname">oper_params</td><td>the operator parameters; the default is to use <code>libint2::default_params(oper)</code> </td></tr>
    <tr><td class="paramname">scalar</td><td>integrals will be scaled by this factor; the default value is 1 </td></tr>
    <tr><td class="paramname">engine_precision</td><td>the (absolute) precision target for the Engine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::shared_ptr to the Engine pool </dd></dl>

</div>
</div>
<a id="a3cae10c8949c00ce0fb88516703d183f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cae10c8949c00ce0fb88516703d183f">&#9670;&nbsp;</a></span>make_integral_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ComputeTile  = Tile, typename Engine  = libint2::Engine&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html">IntegralBuilder</a>&lt;Tile, ComputeTile, Engine&gt; &gt; mpqc::lcao::gaussian::make_integral_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_epool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>shr_screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to make detection of template parameters easier, see <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html" title="Builds integrals from an array of bases and an integral engine pool.">IntegralBuilder</a> for details. </p>

</div>
</div>
<a id="a1e9410ff222048d9db3e3ab7d7ad25e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9410ff222048d9db3e3ab7d7ad25e0">&#9670;&nbsp;</a></span>make_q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ac6221a3b83530af202804bd12b8ee23c">q_vector</a> mpqc::lcao::gaussian::make_q </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13c55803bc67c68c00545f63c95bb3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c55803bc67c68c00545f63c95bb3de">&#9670;&nbsp;</a></span>make_screener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a>&gt; mpqc::lcao::gaussian::make_screener </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; libint2::Engine &gt; &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>screen_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>factory for <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html" title="ThresholdedScreener is a Screener equipped with a (mutable) real threshold.">ThresholdedScreener</a> objects </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Bases</td><td>a directly-addressable sequence of basis sets (or reference proxies, e.g. std::reference_wrapper)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>is a reference to the world in which the distributed screener data will be computed and stores</td></tr>
    <tr><td class="paramname">eng</td><td>is a reference to a ShrPool&lt;E&gt;</td></tr>
    <tr><td class="paramname">bs_array</td><td>is a reference to a directly-addressable sequence of basis sets, if the length is 3 then DF integrals are assumed and the first basis is assumed to be the auxiliary basis if the length is 4 then it is assumed that four center screening is desired. There is no requirement that any basis sets be the same.</td></tr>
    <tr><td class="paramname">screen</td><td>string type of the screener requested; valid values are <code>schwarz</code> (Schwarz screener using the L2 norm), <code>schwarz_inf</code> (Schwarz screener using the infinity norm), <code>qqr</code> (QQR screener using the L2 norm; 4-center only), <code>qqr_inf</code> (QQR screener using the infinity norm; 4-center only) <code>sqvl</code> (SQVl screener using the L2 norm; 3-center only), <code>sqvl_inf</code> (SQVl screener using the infinity norm; 3-center only), <code>default</code> (QQR screener for 4-center ints, SQVl screener for 3-center ints, both L2-based)</td></tr>
    <tr><td class="paramname">screen_threshold</td><td>is the screening threshold</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the screener object </dd></dl>

</div>
</div>
<a id="a4d9799486007f292ac8c597553dce604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9799486007f292ac8c597553dce604">&#9670;&nbsp;</a></span>max_am()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::lcao::gaussian::max_am </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;&#160;</td>
          <td class="paramname"><em>shell_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum angular momement of any shell in the vector. </p>

</div>
</div>
<a id="ae463540711e7a5718ff6f313ac0d84fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae463540711e7a5718ff6f313ac0d84fb">&#9670;&nbsp;</a></span>max_nprim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::lcao::gaussian::max_nprim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;&#160;</td>
          <td class="paramname"><em>shell_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of primatives of any shell in the vector. </p>

</div>
</div>
<a id="a735c5727f3f7be9f0886042c24498b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735c5727f3f7be9f0886042c24498b7e">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; mpqc::lcao::gaussian::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>merges two <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> objects by concatenating their shell cluster sequences. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object in which shells of <code>basis1</code> and <code>basis2</code> </dd></dl>

</div>
</div>
<a id="a40c1488fee63b080b3a2a33923b5a0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c1488fee63b080b3a2a33923b5a0da">&#9670;&nbsp;</a></span>MPQC_EXTERN_TEMPLATE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpqc::lcao::gaussian::MPQC_EXTERN_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt;&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cc401f93b3cf3989932e8749bd51eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc401f93b3cf3989932e8749bd51eee">&#9670;&nbsp;</a></span>nfunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::lcao::gaussian::nfunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;&#160;</td>
          <td class="paramname"><em>shell_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of primatives of any shell in the vector. </p>

</div>
</div>
<a id="ac14daf97f21a6466f9985c84b21333b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14daf97f21a6466f9985c84b21333b6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; mpqc::lcao::gaussian::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_atomic_basis.html">AtomicBasis</a> const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct a map that maps column of basis to column of sub_basis, sub_basis has to be a subset of basis </p><dl class="section warning"><dt>Warning</dt><dd>the value in index starts with 1, value 0 in index indicates this column is missing in sub_basis This approach uses N^2 algorithm //TODO need unit test for this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </td></tr>
    <tr><td class="paramname">sub_basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object, subset of basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of column id of sub_basis </dd></dl>

</div>
</div>
<a id="ab8e9e89bdcfc1878433bdaf57f037006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e9e89bdcfc1878433bdaf57f037006">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; mpqc::lcao::gaussian::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct a map that maps column of basis to column of sub_basis, sub_basis has to be a subset of basis </p><dl class="section warning"><dt>Warning</dt><dd>the value in index starts with 1, value 0 in index indicates this column is missing in sub_basis This approach uses N^2 algorithm //TODO need unit test for this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </td></tr>
    <tr><td class="paramname">sub_basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object, subset of basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of column id of sub_basis </dd></dl>

</div>
</div>
<a id="a5bd9c684fc72526ba39a59078b49c1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd9c684fc72526ba39a59078b49c1ac">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; mpqc::lcao::gaussian::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html">Basis::Factory</a> const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct a map that maps column of basis to column of sub_basis, sub_basis has to be a subset of basis </p><dl class="section warning"><dt>Warning</dt><dd>the value in index starts with 1, value 0 in index indicates this column is missing in sub_basis This approach uses N^2 algorithm //TODO need unit test for this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </td></tr>
    <tr><td class="paramname">sub_basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object, subset of basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of column id of sub_basis </dd></dl>

</div>
</div>
<a id="a755d72248fbad1639c6a94f42bf123a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755d72248fbad1639c6a94f42bf123a1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpqc::lcao::gaussian::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>two</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>merges two <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> objects by concatenating their shell cluster sequences. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object in which shells of <code>basis1</code> and <code>basis2</code> </dd></dl>

</div>
</div>
<a id="affa037266c1937ea7d9b1d7cb4441245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa037266c1937ea7d9b1d7cb4441245">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpqc::lcao::gaussian::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html" title="Class which holds shell set information for screening.">Q2Matrix</a> objects. This does not handle transposes, i.e. it returns false if <code>first</code> is a transpose of <code>second</code> .</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html" title="Class which holds shell set information for screening.">Q2Matrix</a> object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html" title="Class which holds shell set information for screening.">Q2Matrix</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>first</code> refers to the same bases and <code>second</code> and uses same operator type and norm op </dd></dl>

</div>
</div>
<a id="aace25fc31194c5c92a23c5faf3a5bdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace25fc31194c5c92a23c5faf3a5bdc7">&#9670;&nbsp;</a></span>parallel_compute_shellpair_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; size_t &gt; &gt; mpqc::lcao::gaussian::parallel_compute_shellpair_list </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>engine_precision</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This computes non-negligible shell pair list; shells <code>i</code> and <code>j</code> form a non-negligible pair if they share a center or the Frobenius norm of their overlap is greater than threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis1</td><td>a basis </td></tr>
    <tr><td class="paramname">basis2</td><td>a basis </td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of pairs with key: shell index mapped value: a vector of shell indices </dd></dl>

</div>
</div>
<a id="a0d921175ffc2f59e28f7322f23c1441e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d921175ffc2f59e28f7322f23c1441e">&#9670;&nbsp;</a></span>parallel_make_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> mpqc::lcao::gaussian::parallel_make_basis </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html">Basis::Factory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_molecule.html">mpqc::Molecule</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> from a factory and a <a class="el" href="classmpqc_1_1_molecule.html" title="Molecule is a class which contains a vector of AtomBasedClusterables.">Molecule</a> on process 0 and broadcast to the entire world </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>the madness::World </td></tr>
    <tr><td class="paramname">factory</td><td>the <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html" title="Factory is a ctor helper.">Basis::Factory</a> object </td></tr>
    <tr><td class="paramname">mol</td><td>the <a class="el" href="classmpqc_1_1_molecule.html" title="Molecule is a class which contains a vector of AtomBasedClusterables.">Molecule</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmpqc_1_1_uncomputable.html">Uncomputable</a></td><td>if Libint does not include this basis or it is not supported for one or more atoms. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b1c7f2871adeb31e61bbb5b402097b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1c7f2871adeb31e61bbb5b402097b1">&#9670;&nbsp;</a></span>reblock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> mpqc::lcao::gaussian::reblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reblock allows for reblocking a basis </p>
<dl class="section warning"><dt>Warning</dt><dd>If reblocking a basis with the intent to use it with tensors computed with the old basis you must be careful not to reorder the shells.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>should be a function that takes a std::vector&lt;Shell&gt; and returns a std::vector&lt;std::vector&lt;Shell&gt;&gt; for use in initializing a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72a595ca90ad7766876c70a6111bb177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a595ca90ad7766876c70a6111bb177">&#9670;&nbsp;</a></span>reblock_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;libint2::Shell&gt; &gt; mpqc::lcao::gaussian::reblock_basis </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; libint2::Shell &gt;&#160;</td>
          <td class="paramname"><em>shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>blocksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae24f4ec89de556dfce536b5a9088cd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24f4ec89de556dfce536b5a9088cd60">&#9670;&nbsp;</a></span>soad_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engs , typename Tile , typename ComputeTile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::lcao::gaussian::soad_task </td>
          <td>(</td>
          <td class="paramtype">Engs&#160;</td>
          <td class="paramname"><em>eng_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int64_t, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; libint2::Shell &gt; const *, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>obs_row_and_col_ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; libint2::Shell &gt; const *&#160;</td>
          <td class="paramname"><em>min_bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a> *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::DistArray&lt; Tile, Policy &gt; *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>, 3 &gt; *&#160;</td>
          <td class="paramname"><em>shellpair_data_accessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a> &gt;, 2 &gt; *&#160;</td>
          <td class="paramname"><em>jk_screeners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a2de94f551f0988a2180f5e3526f7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2de94f551f0988a2180f5e3526f7c7">&#9670;&nbsp;</a></span>sparse_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt;Tile, TA::SparsePolicy&gt; mpqc::lcao::gaussian::sparse_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct sparse integral tensors in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shr_pool</td><td>should be a std::shared_ptr to an IntegralTSPool </td></tr>
    <tr><td class="paramname">bases</td><td>should be a std::array of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>, which will be copied. </td></tr>
    <tr><td class="paramname">op</td><td>needs to be a function or functor that takes Tile&amp;&amp; and returns an type. Op is copied so it can be moved. <div class="fragment"><div class="line"><span class="keyword">auto</span> t = [](TA::TensorD &amp;&amp;ten){<span class="keywordflow">return</span> std::move(ten);};</div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">screen</td><td>a std::shared_ptr to a <a class="el" href="classmpqc_1_1lcao_1_1_screener.html" title="Base class for screeners will never skip any integrals.">Screener</a>. </td></tr>
    <tr><td class="paramname">make_shellpair_data_accessor</td><td>a functor that makes shellpair data accessors; such accessors are to accept basis function indices, rather than shell indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6700bc880ddaf60393065243c2ce368c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6700bc880ddaf60393065243c2ce368c">&#9670;&nbsp;</a></span>sparse_xyz_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt;Tile, TA::SparsePolicy&gt; mpqc::lcao::gaussian::sparse_xyz_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct set of sparse integral tensors in parallel. </p>
<p>This is needed for integrals such as the dipole integrals that come as a set.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tile</td><td>a (contiguous) tensor type to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shr_pool</td><td>should be a std::shared_ptr to an IntegralTSPool </td></tr>
    <tr><td class="paramname">bases</td><td>should be a std::array of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>, which will be copied. </td></tr>
    <tr><td class="paramname">op</td><td>needs to be a function or functor that takes a TA::TensorD &amp;&amp; and returns any valid tile type. Op is copied so it can be moved. <div class="fragment"><div class="line"><span class="keyword">auto</span> t = [](TA::TensorD &amp;&amp;ten){<span class="keywordflow">return</span> std::move(ten);};</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d324854ba6f208cda3f9bdce132d412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d324854ba6f208cda3f9bdce132d412">&#9670;&nbsp;</a></span>sub_basis_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::RowVectorXi mpqc::lcao::gaussian::sub_basis_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct a map that maps column of basis to column of sub_basis, sub_basis has to be a subset of basis </p><dl class="section warning"><dt>Warning</dt><dd>the value in index starts with 1, value 0 in index indicates this column is missing in sub_basis This approach uses N^2 algorithm //TODO need unit test for this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </td></tr>
    <tr><td class="paramname">sub_basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object, subset of basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of column id of sub_basis </dd></dl>

</div>
</div>
<a id="a495f8506c53e58393a1b7fae3b5c04e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495f8506c53e58393a1b7fae3b5c04e6">&#9670;&nbsp;</a></span>tensorZ_to_tensorD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Policy , bool is_real = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt;TA::TensorD, Policy&gt; mpqc::lcao::gaussian::tensorZ_to_tensorD </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; TA::TensorZ, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>complex_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes real or imaginary part from a complex array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>can be TA::SparsePolicy or TA::DensePolicy </td></tr>
    <tr><td class="paramname">Is_real</td><td>true if user requests real part, false if imaginary </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>TensorZ array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a TensorD array </dd></dl>

</div>
</div>
<a id="a9335060b9b807834dd34448f4e8f2ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9335060b9b807834dd34448f4e8f2ab9">&#9670;&nbsp;</a></span>to_ao_factory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt;Tile, Policy&gt; &gt; mpqc::lcao::gaussian::to_ao_factory </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_a_o_factory.html">lcao::AOFactory</a>&lt; Tile, Policy &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7276834a9db5106be28e8cef8c5def24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7276834a9db5106be28e8cef8c5def24">&#9670;&nbsp;</a></span>to_ao_factory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt;Tile, Policy&gt;&amp; mpqc::lcao::gaussian::to_ao_factory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1_a_o_factory.html">lcao::AOFactory</a>&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aade0cff827d164f6eb0aeb54b8129299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade0cff827d164f6eb0aeb54b8129299">&#9670;&nbsp;</a></span>to_libint2_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libint2::Operator mpqc::lcao::gaussian::to_libint2_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_oper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d1ff3612c49eae3d422bfb65ce33c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1ff3612c49eae3d422bfb65ce33c5b">&#9670;&nbsp;</a></span>to_libint2_operator_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libint2::any mpqc::lcao::gaussian::to_libint2_operator_params </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> &amp;&#160;</td>
          <td class="paramname"><em>molecule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>, libint2::any &gt; *&#160;</td>
          <td class="paramname"><em>oper_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07479e80d39fec6897ee99c6f59e6667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07479e80d39fec6897ee99c6f59e6667">&#9670;&nbsp;</a></span>to_libint2_scale_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libint2::scalar_type mpqc::lcao::gaussian::to_libint2_scale_factor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>, libint2::any &gt; *&#160;</td>
          <td class="paramname"><em>oper_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92beac907f517f3e088b5d1064a132cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92beac907f517f3e088b5d1064a132cf">&#9670;&nbsp;</a></span>to_molden()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrbSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::lcao::gaussian::to_molden </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>fname_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrbSpace &amp;&#160;</td>
          <td class="paramname"><em>orbspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;&#160;</td>
          <td class="paramname"><em>wfn_world</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints an orbital space to a Molden file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OrbSpace</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orbspace</td><td></td></tr>
    <tr><td class="paramname">wfn_world</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01ae2a6d9f9b977526a464c541696afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ae2a6d9f9b977526a464c541696afe">&#9670;&nbsp;</a></span>untruncated_direct_sparse_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt;Tile, TA::SparsePolicy, Engine&gt; mpqc::lcao::gaussian::untruncated_direct_sparse_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5d35833b5878eb21628c0e01ffe4e258">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct direct integral tensors in parallel with screening. </p>
<p>Same requirements on Op as those in Integral Builder.</p>
<p>I only plan to use this for CADF, no point in truncating tiles. </p>

</div>
</div>
<a id="a74c671ec0c925b5d39c9415968df9fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c671ec0c925b5d39c9415968df9fb0">&#9670;&nbsp;</a></span>xyz_integrals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, std::enable_if_t&lt;std::is_same&lt;Policy, TA::DensePolicy&gt;::value, TA::DensePolicy&gt; &gt; mpqc::lcao::gaussian::xyz_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b86eb8ac6c5d51a043d1365c426f3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b86eb8ac6c5d51a043d1365c426f3a4">&#9670;&nbsp;</a></span>xyz_integrals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array_vector.html">TA::DistArrayVector</a>&lt; Tile, std::enable_if_t&lt;std::is_same&lt;Policy, TA::SparsePolicy&gt;::value, TA::SparsePolicy&gt; &gt; mpqc::lcao::gaussian::xyz_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aaabe21bf203cac1b6a1c55dd5093e288">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Fri Feb 12 2021 13:12:42 for <a href="http://www.mpqc.org">MPQC</a>
    4.0.0-beta.1 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.20
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
